# 3. get - 단일 레코드 조회

## 개요
Feature Group에서 특정 레코드 식별자를 사용하여 단일 레코드를 조회합니다.

## 기본 사용법
```bash
fs get FEATURE_GROUP_NAME RECORD_IDENTIFIER_VALUE [OPTIONS]
```

## 필수 인자
- `FEATURE_GROUP_NAME`: 조회할 Feature Group 이름
- `RECORD_IDENTIFIER_VALUE`: 레코드 식별자 값

## 옵션
- `--feature-names TEXT`: 조회할 피처 이름들 (쉼표로 구분)
- `--output-format, -o [table|json]`: 출력 형식 (기본값: json)

## 상세 사용 예시

### 1. 기본 레코드 조회 (JSON 형태)
```bash
fs get customer-profile cust_12345
```

**출력 예시:**
```json
{
  "customer_id": "cust_12345",
  "event_time": "2024-01-15T10:30:00Z",
  "age": "35",
  "balance": "1250.75",
  "category": "premium",
  "last_login": "2024-01-15T09:45:00Z",
  "purchase_count": "23"
}
```

### 2. 테이블 형태로 조회
```bash
fs get customer-profile cust_12345 --output-format table
```

**출력 예시:**
```
+-------------+----------------------+-----+---------+----------+----------------------+----------------+
| customer_id | event_time           | age | balance | category | last_login           | purchase_count |
+=============+======================+=====+=========+==========+======================+================+
| cust_12345  | 2024-01-15T10:30:00Z | 35  | 1250.75 | premium  | 2024-01-15T09:45:00Z | 23             |
+-------------+----------------------+-----+---------+----------+----------------------+----------------+
```

### 3. 특정 피처만 조회
```bash
fs get customer-profile cust_12345 --feature-names "customer_id,age,balance"
```

**출력 예시:**
```json
{
  "customer_id": "cust_12345",
  "age": "35",
  "balance": "1250.75"
}
```

### 4. 여러 피처를 테이블 형태로 조회
```bash
fs get customer-profile cust_12345 \
  --feature-names "customer_id,age,balance,category" \
  --output-format table
```

### 5. 모든 피처를 테이블 형태로 조회
```bash
fs get customer-profile cust_12345 -o table
```

## 고급 사용 시나리오

### 1. 실시간 데이터 조회 및 검증
```bash
# 최신 데이터 조회
CUSTOMER_ID="cust_67890"
fs get real-time-features $CUSTOMER_ID

# 특정 피처만 조회하여 검증
fs get real-time-features $CUSTOMER_ID \
  --feature-names "customer_id,last_activity,session_count" \
  --output-format table
```

### 2. 배치 스크립트에서 활용
```bash
#!/bin/bash
FEATURE_GROUP="user-profile"
USER_IDS=("user_001" "user_002" "user_003")

for user_id in "${USER_IDS[@]}"; do
  echo "=== User: $user_id ==="
  fs get $FEATURE_GROUP $user_id \
    --feature-names "user_id,age,subscription_type" \
    --output-format table
  echo ""
done
```

### 3. JSON 출력을 jq로 파싱
```bash
# 특정 필드만 추출
fs get customer-profile cust_12345 | jq '.balance'

# 숫자형 필드 계산
BALANCE=$(fs get customer-profile cust_12345 | jq -r '.balance')
echo "Balance: $BALANCE"

# 조건부 검사
fs get customer-profile cust_12345 | \
  jq 'if (.balance | tonumber) > 1000 then "VIP" else "Regular" end'
```

### 4. 다중 Feature Group에서 동일 ID 조회
```bash
RECORD_ID="shared_id_123"

echo "=== Profile Data ==="
fs get customer-profile $RECORD_ID

echo "=== Activity Data ==="
fs get customer-activity $RECORD_ID

echo "=== Preferences Data ==="
fs get customer-preferences $RECORD_ID
```

### 5. 데이터 존재 여부 확인
```bash
#!/bin/bash
check_record_exists() {
  local feature_group=$1
  local record_id=$2
  
  result=$(fs get $feature_group $record_id 2>/dev/null)
  if [ $? -eq 0 ]; then
    echo "Record $record_id exists in $feature_group"
    return 0
  else
    echo "Record $record_id not found in $feature_group"
    return 1
  fi
}

check_record_exists "customer-profile" "cust_12345"
```

### 6. 시간별 데이터 추적
```bash
#!/bin/bash
FEATURE_GROUP="session-data"
SESSION_ID="session_abc123"

# 5분마다 세션 데이터 확인
while true; do
  echo "$(date): Checking session $SESSION_ID"
  fs get $FEATURE_GROUP $SESSION_ID \
    --feature-names "session_id,status,last_update" \
    --output-format table
  sleep 300
done
```

## 데이터 타입별 처리

### 1. 문자열 데이터 처리
```bash
# JSON에서 문자열 추출
CATEGORY=$(fs get customer-profile cust_12345 | jq -r '.category')
echo "Customer category: $CATEGORY"

# 특정 문자열 패턴 확인
fs get customer-profile cust_12345 | \
  jq 'select(.category | contains("premium"))'
```

### 2. 숫자 데이터 처리
```bash
# 숫자형 데이터 추출 및 계산
AGE=$(fs get customer-profile cust_12345 | jq -r '.age | tonumber')
BALANCE=$(fs get customer-profile cust_12345 | jq -r '.balance | tonumber')

echo "Age: $AGE, Balance: $BALANCE"

# 조건부 처리
if (( $(echo "$BALANCE > 1000" | bc -l) )); then
  echo "High-value customer"
fi
```

### 3. 시간 데이터 처리
```bash
# ISO 8601 시간 파싱
EVENT_TIME=$(fs get customer-profile cust_12345 | jq -r '.event_time')
echo "Event time: $EVENT_TIME"

# Unix timestamp로 변환
UNIX_TIME=$(date -d "$EVENT_TIME" +%s)
echo "Unix timestamp: $UNIX_TIME"
```

## 성능 최적화

### 1. 필요한 피처만 조회
```bash
# 비효율적 - 모든 피처 조회
fs get large-feature-group record_123

# 효율적 - 필요한 피처만 조회  
fs get large-feature-group record_123 \
  --feature-names "id,essential_field1,essential_field2"
```

### 2. 출력 형식 최적화
```bash
# 스크립트에서 사용 시 JSON이 효율적
fs get customer-profile cust_12345 | jq '.balance'

# 사람이 읽기 위해서는 table 형식
fs get customer-profile cust_12345 -o table
```

### 3. 대용량 데이터 처리
```bash
# 벡터 데이터나 큰 텍스트가 포함된 경우 특정 피처만 조회
fs get embedding-features item_456 \
  --feature-names "item_id,category" \
  # embedding 필드는 제외 (용량이 클 수 있음)
```

## 오류 처리 및 문제 해결

### 1. 레코드가 존재하지 않는 경우
```bash
# 오류 예시
fs get customer-profile nonexistent_id
# 출력: Record not found 또는 빈 결과

# 스크립트에서 오류 처리
#!/bin/bash
RESULT=$(fs get customer-profile $RECORD_ID 2>/dev/null)
if [ -z "$RESULT" ]; then
  echo "Record not found: $RECORD_ID"
  exit 1
fi
```

### 2. Feature Group이 존재하지 않는 경우
```bash
# 오류 예시
fs get nonexistent-fg record_123
# 출력: Feature group not found

# 사전에 Feature Group 존재 확인
fs list | grep -q "target-feature-group" || {
  echo "Feature group not found"
  exit 1
}
```

### 3. 권한 문제
```bash
# 오류: AccessDenied
# 필요한 권한:
# - sagemaker-featurestore-runtime:GetRecord
# - Feature Group에 대한 접근 권한

# IAM 정책 예시 확인 방법
aws sts get-caller-identity  # 현재 역할 확인
```

### 4. Online Store가 비활성화된 경우
```bash
# 오류: Online store is not enabled
# 해결: Feature Group 생성 시 Online Store 활성화 필요
# 또는 bulk-get을 사용하여 Offline Store에서 조회
```

## 모니터링 및 로깅

### 1. 조회 성능 측정
```bash
#!/bin/bash
FEATURE_GROUP="performance-test"
RECORD_ID="test_record"

# 시간 측정
start_time=$(date +%s.%N)
fs get $FEATURE_GROUP $RECORD_ID > /dev/null
end_time=$(date +%s.%N)

duration=$(echo "$end_time - $start_time" | bc)
echo "Query took: ${duration}s"
```

### 2. 대량 조회 성능 테스트
```bash
#!/bin/bash
FEATURE_GROUP="load-test-fg"
RECORD_IDS=("id1" "id2" "id3" "id4" "id5")

start_total=$(date +%s.%N)
for id in "${RECORD_IDS[@]}"; do
  start=$(date +%s.%N)
  fs get $FEATURE_GROUP $id > /dev/null
  end=$(date +%s.%N)
  duration=$(echo "$end - $start" | bc)
  echo "Record $id: ${duration}s"
done
end_total=$(date +%s.%N)

total_duration=$(echo "$end_total - $start_total" | bc)
echo "Total time: ${total_duration}s"
```

### 3. 조회 결과 로깅
```bash
#!/bin/bash
LOG_FILE="/var/log/feature_queries.log"
FEATURE_GROUP="audit-features"
RECORD_ID="$1"

{
  echo "$(date '+%Y-%m-%d %H:%M:%S') - Querying $FEATURE_GROUP:$RECORD_ID"
  fs get $FEATURE_GROUP $RECORD_ID
  echo "Query completed"
  echo "---"
} | tee -a $LOG_FILE
```

## 데이터 검증 및 품질 확인

### 1. 데이터 완정성 검사
```bash
#!/bin/bash
validate_record() {
  local feature_group=$1
  local record_id=$2
  
  result=$(fs get $feature_group $record_id)
  
  # 필수 필드 확인
  required_fields=("customer_id" "age" "balance")
  for field in "${required_fields[@]}"; do
    value=$(echo "$result" | jq -r ".$field")
    if [ "$value" = "null" ] || [ -z "$value" ]; then
      echo "Missing required field: $field"
      return 1
    fi
  done
  
  # 데이터 타입 검증
  age=$(echo "$result" | jq -r '.age | tonumber')
  if [ "$age" -lt 0 ] || [ "$age" -gt 120 ]; then
    echo "Invalid age: $age"
    return 1
  fi
  
  echo "Record validation passed"
  return 0
}

validate_record "customer-profile" "cust_12345"
```

### 2. 데이터 일관성 검사
```bash
#!/bin/bash
check_consistency() {
  local record_id=$1
  
  profile=$(fs get customer-profile $record_id | jq -r '.customer_id')
  activity=$(fs get customer-activity $record_id | jq -r '.customer_id')
  
  if [ "$profile" != "$activity" ]; then
    echo "Inconsistency detected for record: $record_id"
    return 1
  fi
  
  echo "Consistency check passed for: $record_id"
  return 0
}
```

## 통합 시나리오

### 1. 고객 360도 뷰 생성
```bash
#!/bin/bash
get_customer_360() {
  local customer_id=$1
  
  echo "=== Customer 360 View: $customer_id ==="
  
  echo "Profile:"
  fs get customer-profile $customer_id \
    --feature-names "age,category,balance" \
    --output-format table
  
  echo -e "\nActivity:"
  fs get customer-activity $customer_id \
    --feature-names "last_login,session_count,page_views" \
    --output-format table
    
  echo -e "\nPreferences:"
  fs get customer-preferences $customer_id \
    --feature-names "preferred_category,newsletter_subscribed" \
    --output-format table
}

get_customer_360 "cust_12345"
```

### 2. 실시간 추천을 위한 피처 수집
```bash
#!/bin/bash
get_recommendation_features() {
  local user_id=$1
  
  # 사용자 프로필
  user_profile=$(fs get user-profile $user_id \
    --feature-names "age,category,location")
  
  # 최근 활동
  recent_activity=$(fs get user-activity $user_id \
    --feature-names "last_viewed_categories,purchase_history")
    
  # 실시간 세션
  session_data=$(fs get user-session $user_id \
    --feature-names "current_session_duration,pages_viewed")
  
  # 결합된 피처 출력
  echo "$user_profile" "$recent_activity" "$session_data" | \
    jq -s 'add'
}

get_recommendation_features "user_789"
```

## 모범 사례

1. **필요한 피처만 조회**: 네트워크 대역폭과 지연시간 최적화
2. **출력 형식 적절히 선택**: 스크립트는 JSON, 사람은 table
3. **오류 처리 구현**: 레코드 미존재, 권한 오류 등에 대한 적절한 처리
4. **성능 모니터링**: 조회 시간 측정 및 최적화
5. **데이터 검증**: 조회된 데이터의 유효성 검사

## 관련 명령어
- `fs bulk-get`: 대량 레코드 조회
- `fs put`: 단일 레코드 입력
- `fs list`: Feature Group 목록 조회
- `fs schema`: 스키마 정보 확인