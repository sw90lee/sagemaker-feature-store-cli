# 12. add-features 명령어

기존 Feature Group에 새로운 feature들을 추가하는 명령어입니다.

## 기본 사용법

### 1. JSON 파일 방식 (기존)
```bash
# 새로운 feature 추가
fs add-features my-feature-group features.json

# 실제 추가 전 미리보기
fs add-features my-feature-group features.json --dry-run

# 백그라운드로 실행 (완료 대기 안함)
fs add-features my-feature-group features.json --no-wait
```

### 2. CLI 플래그 방식 (신규)
```bash
# 기본 feature 추가
fs add-feature my-fg -f "age:Integral:사용자 나이" -f "name:String:사용자 이름"

# 벡터 feature 추가  
fs add-feature my-fg -f "embeddings:String:list:256:텍스트 임베딩"

# 집합 feature 추가
fs add-feature my-fg -f "tags:String:set:사용자 태그"
```

### 3. JSON 문자열 방식 (신규)
```bash
# JSON 문자열로 feature 추가
fs add-feature-json my-fg \
  -j '{"FeatureName": "score", "FeatureType": "Fractional"}' \
  -j '{"FeatureName": "category", "FeatureType": "String"}'

# 벡터 feature JSON으로 추가
fs add-feature-json my-fg \
  -j '{"FeatureName": "vector", "FeatureType": "String", "CollectionType": "List", "CollectionConfig": {"VectorConfig": {"Dimension": 256}}}'
```

## 명령어 옵션

### `add-features` (JSON 파일 방식)
| 옵션 | 설명 | 기본값 |
|------|------|--------|
| `FEATURE_GROUP_NAME` | 대상 Feature Group 이름 (필수) | - |
| `FEATURES_FILE` | 새로운 feature definition JSON 파일 (필수) | - |
| `--dry-run` | 실제 추가 없이 미리보기만 실행 | False |
| `--wait/--no-wait` | 업데이트 완료까지 대기 여부 | True |

### `add-feature` (CLI 플래그 방식)
| 옵션 | 설명 | 기본값 |
|------|------|--------|
| `FEATURE_GROUP_NAME` | 대상 Feature Group 이름 (필수) | - |
| `--feature`, `-f` | Feature 정의 문자열 (복수 가능) | - |
| `--dry-run` | 실제 추가 없이 미리보기만 실행 | False |
| `--wait/--no-wait` | 업데이트 완료까지 대기 여부 | True |

### `add-feature-json` (JSON 문자열 방식)  
| 옵션 | 설명 | 기본값 |
|------|------|--------|
| `FEATURE_GROUP_NAME` | 대상 Feature Group 이름 (필수) | - |
| `--json`, `-j` | JSON 형태의 feature 정의 (복수 가능) | - |
| `--dry-run` | 실제 추가 없이 미리보기만 실행 | False |
| `--wait/--no-wait` | 업데이트 완료까지 대기 여부 | True |

## CLI 플래그 방식 Feature 정의 형식

### 기본 형식
```
name:type[:description]
```

### 벡터 형식  
```
name:type:list:dimension[:description]
```

### 집합 형식
```
name:type:set[:description]
```

### 예시
- `"age:Integral"` - 기본 정수형 feature
- `"name:String:사용자 이름"` - 설명이 있는 문자열 feature
- `"embeddings:String:list:256:텍스트 임베딩"` - 256차원 벡터 feature
- `"tags:String:set:사용자 태그 집합"` - 집합 타입 feature

## Feature Definition 파일 형식

새로운 feature들은 JSON 배열 형태로 정의합니다:

```json
[
  {
    "FeatureName": "user_age_category",
    "FeatureType": "String",
    "Description": "사용자 연령대 카테고리"
  },
  {
    "FeatureName": "purchase_amount",
    "FeatureType": "Fractional",
    "Description": "구매 금액"
  },
  {
    "FeatureName": "product_embeddings",
    "FeatureType": "String",
    "CollectionType": "List",
    "CollectionConfig": {
      "VectorConfig": {
        "Dimension": 256
      }
    },
    "Description": "상품 임베딩 벡터"
  }
]
```

### 지원하는 Feature Type

| Type | 설명 | 예시 |
|------|------|------|
| `String` | 문자열 데이터 | "premium", "active" |
| `Integral` | 정수형 데이터 | 25, 100, -5 |
| `Fractional` | 실수형 데이터 | 3.14, 99.99 |

### 지원하는 Collection Type

| Type | 설명 | 예시 | 제한사항 |
|------|------|------|---------|
| `List` | 벡터/배열 형태 | [0.1, 0.2, 0.3] | **Iceberg 테이블 형식에서만 지원** |
| `Set` | 집합 형태 | {"red", "blue"} | 모든 테이블 형식에서 지원 |

⚠️ **중요**: 벡터(List) 타입 feature는 Feature Group이 **Iceberg 테이블 형식**으로 생성되어야만 사용할 수 있습니다. Glue 테이블 형식에서는 벡터 feature를 지원하지 않습니다.

## 상세 사용 예시

### 1. CLI 플래그 방식으로 Feature 추가 (신규)

#### 기본 Feature 추가
```bash
# 단일 feature 추가
fs add-feature my-feature-group -f "user_score:Fractional:사용자 점수"

# 여러 feature 동시 추가
fs add-feature customer-profiles \
  -f "age:Integral:고객 나이" \
  -f "income:Fractional:연간 소득" \
  -f "status:String:고객 상태"

# 미리보기로 확인
fs add-feature customer-profiles \
  -f "new_field:String:새로운 필드" \
  --dry-run
```

**실행 예시:**
```bash
$ fs add-feature customer-profiles \
    -f "loyalty_score:Fractional:고객 충성도 점수" \
    -f "preferred_channel:String:선호 채널" \
    --dry-run

🚀 CLI 플래그 기반 Feature 추가 프로세스 시작...
✓ 현재 Feature Group: customer-profiles
✓ 기존 feature 수: 15
✓ 추가할 feature 수: 2
  + loyalty_score (Fractional)
    설명: 고객 충성도 점수
  + preferred_channel (String)
    설명: 선호 채널
🔍 [DRY RUN] 실제 추가하지 않고 미리보기만 실행합니다.
```

#### 벡터 Feature 추가
```bash
# 텍스트 임베딩 벡터 추가
fs add-feature ml-features \
  -f "text_embeddings:String:list:768:BERT 기반 텍스트 임베딩"

# 이미지 특성 벡터 추가  
fs add-feature vision-features \
  -f "image_features:String:list:2048:ResNet 이미지 특성" \
  -f "object_detection:String:list:100:객체 탐지 결과"

# 사용자 행동 패턴 벡터
fs add-feature user-behavior \
  -f "behavior_vector:String:list:50:사용자 행동 패턴 벡터"
```

**실행 예시:**
```bash
$ fs add-feature ml-features \
    -f "sentence_embeddings:String:list:384:Sentence-BERT 임베딩" \
    -f "user_profile_vector:String:list:128:사용자 프로필 벡터"

🚀 CLI 플래그 기반 Feature 추가 프로세스 시작...
✓ 현재 Feature Group: ml-features  
✓ 기존 feature 수: 12
✓ 추가할 feature 수: 2
  + sentence_embeddings (String [List](384D))
    설명: Sentence-BERT 임베딩
  + user_profile_vector (String [List](128D))
    설명: 사용자 프로필 벡터
📝 Feature 추가 중...
✓ Feature 추가 요청이 성공적으로 전송되었습니다!
⏳ Feature 추가 완료까지 대기 중...
✅ Feature 추가가 완료되었습니다!
```

#### 집합 타입 Feature 추가
```bash
# 사용자 태그 집합
fs add-feature user-profiles \
  -f "user_tags:String:set:사용자가 선택한 태그들"

# 관심 카테고리 집합
fs add-feature customer-data \
  -f "interest_categories:String:set:관심 있는 상품 카테고리"

# 방문한 페이지 집합
fs add-feature analytics \
  -f "visited_pages:String:set:방문한 페이지 목록"
```

**복합 예시:**
```bash
# 다양한 타입의 feature들을 한 번에 추가
fs add-feature ecommerce-analytics \
  -f "customer_tier:String:고객 등급 (Bronze/Silver/Gold/Platinum)" \
  -f "avg_order_value:Fractional:평균 주문 금액" \
  -f "purchase_frequency:Integral:월평균 구매 횟수" \
  -f "product_categories:String:set:구매한 상품 카테고리들" \
  -f "behavior_embeddings:String:list:256:구매 행동 임베딩 벡터"
```

### 2. JSON 문자열 방식으로 Feature 추가 (신규)

#### 기본 JSON Feature 추가
```bash
# 단일 JSON feature
fs add-feature-json my-feature-group \
  -j '{"FeatureName": "conversion_rate", "FeatureType": "Fractional", "Description": "전환율"}'

# 여러 JSON features 동시 추가
fs add-feature-json ecommerce-features \
  -j '{"FeatureName": "order_count", "FeatureType": "Integral", "Description": "주문 횟수"}' \
  -j '{"FeatureName": "total_spent", "FeatureType": "Fractional", "Description": "총 지출 금액"}' \
  -j '{"FeatureName": "customer_tier", "FeatureType": "String", "Description": "고객 등급"}'
```

**실행 예시:**
```bash
$ fs add-feature-json analytics-features \
    -j '{"FeatureName": "bounce_rate", "FeatureType": "Fractional", "Description": "바운스율"}' \
    -j '{"FeatureName": "session_duration", "FeatureType": "Integral", "Description": "세션 지속시간(초)"}' \
    --dry-run

🚀 JSON 문자열 기반 Feature 추가 프로세스 시작...
✓ 현재 Feature Group: analytics-features
✓ 기존 feature 수: 8
✓ 추가할 feature 수: 2
  + bounce_rate (Fractional)
    설명: 바운스율
  + session_duration (Integral)
    설명: 세션 지속시간(초)
🔍 [DRY RUN] 실제 추가하지 않고 미리보기만 실행합니다.
```

#### 복잡한 벡터 Feature JSON으로 추가
```bash
# 고차원 임베딩 벡터
fs add-feature-json ml-pipeline \
  -j '{
    "FeatureName": "document_embeddings",
    "FeatureType": "String",
    "CollectionType": "List", 
    "CollectionConfig": {
      "VectorConfig": {
        "Dimension": 1536
      }
    },
    "Description": "OpenAI 임베딩 벡터"
  }'

# 다중 모달 특성 벡터
fs add-feature-json multimodal-features \
  -j '{
    "FeatureName": "audio_features",
    "FeatureType": "String",
    "CollectionType": "List",
    "CollectionConfig": {
      "VectorConfig": {
        "Dimension": 512
      }
    },
    "Description": "오디오 특성 벡터"
  }' \
  -j '{
    "FeatureName": "video_features", 
    "FeatureType": "String",
    "CollectionType": "List",
    "CollectionConfig": {
      "VectorConfig": {
        "Dimension": 1024
      }
    },
    "Description": "비디오 특성 벡터"
  }'
```

#### 자동화 스크립트에서 활용
```bash
#!/bin/bash
# 동적으로 feature를 추가하는 예시

# 변수 설정
FEATURE_GROUP="real-time-analytics"
BASE_FEATURES=(
  "page_views:Integral:페이지뷰 수"
  "unique_visitors:Integral:순방문자 수" 
  "conversion_rate:Fractional:전환율"
)
ADVANCED_FEATURES=(
  "user_journey_embeddings:String:list:512:사용자 여정 임베딩"
  "behavioral_clusters:String:set:행동 클러스터"
)

echo "📊 실시간 분석 Feature Group 구성 중..."

# 기본 features 먼저 추가
echo "🔧 기본 features 추가..."
for feature in "${BASE_FEATURES[@]}"; do
  echo "  추가 중: $feature"
  fs add-feature "$FEATURE_GROUP" -f "$feature" --no-wait
done

# 잠시 대기
echo "⏳ 기본 features 완료 대기..."
sleep 30

# 고급 features 추가
echo "🚀 고급 features 추가..."
for feature in "${ADVANCED_FEATURES[@]}"; do
  echo "  추가 중: $feature"
  fs add-feature "$FEATURE_GROUP" -f "$feature" --no-wait
done

echo "✅ 모든 features 추가 요청 완료"
```

### 3. 기존 JSON 파일 방식으로 Feature 추가

#### 기본 Feature 추가

```bash
# 1. Feature definition 파일 생성
cat > new_features.json << EOF
[
  {
    "FeatureName": "customer_segment",
    "FeatureType": "String",
    "Description": "고객 세그먼트 분류"
  },
  {
    "FeatureName": "lifetime_value",
    "FeatureType": "Fractional", 
    "Description": "고객 생애 가치"
  },
  {
    "FeatureName": "interaction_count",
    "FeatureType": "Integral",
    "Description": "총 상호작용 횟수"
  }
]
EOF

# 2. 미리보기로 확인
fs add-features customer-profiles new_features.json --dry-run

# 출력 예시:
# 🚀 Feature 추가 프로세스 시작...
# ✓ 현재 Feature Group: customer-profiles
# ✓ 기존 feature 수: 8
# ✓ 추가할 feature 수: 3
#   + customer_segment (String)
#   + lifetime_value (Fractional)
#   + interaction_count (Integral)
# 🔍 [DRY RUN] 실제 추가하지 않고 미리보기만 실행합니다.

# 3. 실제 추가
fs add-features customer-profiles new_features.json

# 출력 예시:
# 📝 Feature 추가 중...
# ✓ Feature 추가 요청이 성공적으로 전송되었습니다!
# ⏳ Feature 추가 완료까지 대기 중...
# ✅ Feature 추가가 완료되었습니다!
```

### 벡터/임베딩 Feature 추가

```bash
# 고차원 벡터 feature 정의
cat > embedding_features.json << EOF
[
  {
    "FeatureName": "text_embeddings",
    "FeatureType": "String",
    "CollectionType": "List",
    "CollectionConfig": {
      "VectorConfig": {
        "Dimension": 768
      }
    },
    "Description": "텍스트 임베딩 벡터 (BERT 기반)"
  },
  {
    "FeatureName": "image_features",
    "FeatureType": "String", 
    "CollectionType": "List",
    "CollectionConfig": {
      "VectorConfig": {
        "Dimension": 2048
      }
    },
    "Description": "이미지 특성 벡터 (ResNet 기반)"
  },
  {
    "FeatureName": "user_tags",
    "FeatureType": "String",
    "CollectionType": "Set",
    "Description": "사용자 태그 집합"
  }
]
EOF

fs add-features ml-features embedding_features.json
```

### 복합 데이터 타입 Feature 추가

```bash
# 다양한 타입의 feature들을 한 번에 추가
cat > complex_features.json << EOF
[
  {
    "FeatureName": "purchase_history_summary",
    "FeatureType": "String",
    "Description": "구매 이력 요약 (JSON 문자열)"
  },
  {
    "FeatureName": "product_ratings",
    "FeatureType": "String",
    "CollectionType": "List",
    "CollectionConfig": {
      "VectorConfig": {
        "Dimension": 100
      }
    },
    "Description": "상품별 평점 배열"
  },
  {
    "FeatureName": "preferred_categories",
    "FeatureType": "String",
    "CollectionType": "Set",
    "Description": "선호 카테고리 집합"
  },
  {
    "FeatureName": "recommendation_score",
    "FeatureType": "Fractional",
    "Description": "추천 점수"
  },
  {
    "FeatureName": "visit_frequency",
    "FeatureType": "Integral", 
    "Description": "월간 방문 횟수"
  }
]
EOF

fs add-features ecommerce-features complex_features.json
```

## 고급 사용 시나리오

### 1. 배치 Feature 추가 시스템

```bash
#!/bin/bash
# batch_feature_addition.sh - 여러 Feature Group에 일관된 feature 추가

FEATURE_GROUPS=("user_profiles" "product_catalog" "transaction_history")
FEATURE_FILE="common_analytics_features.json"

# 공통으로 추가할 analytics feature들
cat > "$FEATURE_FILE" << EOF
[
  {
    "FeatureName": "created_timestamp",
    "FeatureType": "Fractional",
    "Description": "레코드 생성 타임스탬프 (Unix epoch)"
  },
  {
    "FeatureName": "last_updated",
    "FeatureType": "String", 
    "Description": "마지막 업데이트 시간 (ISO 8601)"
  },
  {
    "FeatureName": "data_version",
    "FeatureType": "String",
    "Description": "데이터 버전 정보"
  },
  {
    "FeatureName": "quality_score",
    "FeatureType": "Fractional",
    "Description": "데이터 품질 점수 (0.0-1.0)"
  }
]
EOF

echo "🚀 배치 Feature 추가 프로세스 시작"
echo "대상 Feature Groups: ${FEATURE_GROUPS[*]}"
echo "추가할 Feature 파일: $FEATURE_FILE"
echo ""

successful_updates=0
failed_updates=0
update_log="batch_update_$(date +%Y%m%d_%H%M%S).log"

for fg in "${FEATURE_GROUPS[@]}"; do
    echo "📊 Processing: $fg"
    
    # 미리보기 실행
    echo "  🔍 미리보기 실행 중..." | tee -a "$update_log"
    if fs add-features "$fg" "$FEATURE_FILE" --dry-run >> "$update_log" 2>&1; then
        echo "  ✅ 미리보기 성공"
        
        # 실제 업데이트 실행
        echo "  📝 Feature 추가 중..." | tee -a "$update_log"
        if fs add-features "$fg" "$FEATURE_FILE" >> "$update_log" 2>&1; then
            echo "  ✅ $fg 업데이트 성공"
            successful_updates=$((successful_updates + 1))
        else
            echo "  ❌ $fg 업데이트 실패"
            failed_updates=$((failed_updates + 1))
        fi
    else
        echo "  ❌ $fg 미리보기 실패 (스킵됨)"
        failed_updates=$((failed_updates + 1))
    fi
    
    echo ""
    
    # API 제한 고려한 딜레이
    sleep 2
done

# 결과 요약
echo "📋 배치 업데이트 완료"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "총 대상: ${#FEATURE_GROUPS[@]}개"
echo "성공: $successful_updates개"
echo "실패: $failed_updates개"
echo "로그 파일: $update_log"

# 실패한 경우 로그 표시
if [ $failed_updates -gt 0 ]; then
    echo ""
    echo "❌ 실패 상세 정보:"
    grep -A 5 -B 2 "실패\|error\|Error" "$update_log" || true
fi

echo ""
echo "🔍 모든 Feature Group 현재 상태 확인:"
for fg in "${FEATURE_GROUPS[@]}"; do
    echo ""
    echo "📊 $fg:"
    fs schema "$fg" --format table | head -10
done

# 정리
rm -f "$FEATURE_FILE"
```

### 2. 스키마 진화 관리 시스템

```bash
#!/bin/bash
# schema_evolution_manager.sh - Feature Group 스키마 버전 관리

FEATURE_GROUP="$1"
EVOLUTION_DIR="schema_evolution"

if [ -z "$FEATURE_GROUP" ]; then
    echo "사용법: $0 <feature-group-name>"
    exit 1
fi

echo "📈 스키마 진화 관리: $FEATURE_GROUP"
echo "진화 디렉토리: $EVOLUTION_DIR"

# 진화 디렉토리 생성
mkdir -p "$EVOLUTION_DIR/$FEATURE_GROUP"

# 현재 스키마 백업
current_schema_file="$EVOLUTION_DIR/$FEATURE_GROUP/schema_$(date +%Y%m%d_%H%M%S).json"
echo "💾 현재 스키마 백업 중: $current_schema_file"

fs schema "$FEATURE_GROUP" --format json > "$current_schema_file"

if [ $? -eq 0 ]; then
    echo "✅ 스키마 백업 완료"
    
    # 스키마 진화 히스토리 업데이트
    history_file="$EVOLUTION_DIR/$FEATURE_GROUP/evolution_history.txt"
    
    current_feature_count=$(jq '.TotalFeatures' "$current_schema_file")
    
    echo "$(date '+%Y-%m-%d %H:%M:%S') | Features: $current_feature_count | File: $(basename $current_schema_file)" >> "$history_file"
    
    # 진화 히스토리 표시
    echo ""
    echo "📚 스키마 진화 히스토리:"
    if [ -f "$history_file" ]; then
        tail -10 "$history_file" | while read -r line; do
            echo "  $line"
        done
    else
        echo "  첫 번째 스키마 백업"
    fi
    
    # 스키마 변경 계획 템플릿 생성
    evolution_plan="$EVOLUTION_DIR/$FEATURE_GROUP/next_evolution_plan.json"
    
    if [ ! -f "$evolution_plan" ]; then
        echo ""
        echo "📋 스키마 진화 계획 템플릿 생성: $evolution_plan"
        
        cat > "$evolution_plan" << 'EOF'
{
  "evolution_version": "v1.1",
  "description": "다음 스키마 진화 계획",
  "planned_date": "YYYY-MM-DD",
  "features_to_add": [
    {
      "FeatureName": "new_feature_name",
      "FeatureType": "String|Integral|Fractional",
      "Description": "새로운 feature 설명",
      "rationale": "추가하는 이유"
    }
  ],
  "impact_assessment": {
    "breaking_changes": false,
    "downstream_systems_affected": [],
    "rollback_plan": "롤백 계획 설명"
  },
  "testing_checklist": [
    "새 feature로 데이터 입력 테스트",
    "기존 쿼리 영향도 확인",
    "ML 파이프라인 호환성 검증"
  ]
}
EOF
        echo "✅ 템플릿 생성 완료"
        echo ""
        echo "💡 사용법:"
        echo "  1. $evolution_plan 파일을 편집하여 진화 계획 수립"
        echo "  2. 계획 파일에서 features_to_add 배열을 추출하여 add-features 실행"
        echo "  3. 실행 후 이 스크립트를 다시 실행하여 변경 사항 추적"
    fi
    
    # 이전 스키마와 비교 (두 번째 실행부터)
    previous_schemas=($(ls -t "$EVOLUTION_DIR/$FEATURE_GROUP"/schema_*.json 2>/dev/null | tail -n +2))
    
    if [ ${#previous_schemas[@]} -gt 0 ]; then
        previous_schema="${previous_schemas[0]}"
        echo ""
        echo "🔄 이전 스키마와 비교:"
        echo "  현재: $current_feature_count개 features"
        
        previous_count=$(jq '.TotalFeatures' "$previous_schema")
        echo "  이전: $previous_count개 features"
        
        if [ "$current_feature_count" -gt "$previous_count" ]; then
            added_count=$((current_feature_count - previous_count))
            echo "  📈 $added_count개 feature 추가됨"
            
            # 새로 추가된 feature들 찾기
            echo ""
            echo "🆕 새로 추가된 features:"
            
            # Python을 사용한 차이점 분석
            python3 << EOF
import json
import sys

try:
    with open('$current_schema_file', 'r') as f:
        current = json.load(f)
    with open('$previous_schema', 'r') as f:
        previous = json.load(f)
    
    current_features = {f['FeatureName']: f for f in current['FeatureDefinitions']}
    previous_features = {f['FeatureName']: f for f in previous['FeatureDefinitions']}
    
    new_features = set(current_features.keys()) - set(previous_features.keys())
    
    for feature_name in sorted(new_features):
        feature = current_features[feature_name]
        print(f"  + {feature_name} ({feature['FeatureType']})")
        if 'Description' in feature:
            print(f"    설명: {feature['Description']}")

except Exception as e:
    print(f"비교 중 오류: {e}")
EOF
        elif [ "$current_feature_count" -eq "$previous_count" ]; then
            echo "  ➡️  변경 없음"
        fi
    fi
    
    # 스키마 정합성 검사
    echo ""
    echo "🔍 스키마 정합성 검사:"
    
    # 중복 feature 이름 확인
    duplicate_count=$(jq -r '.FeatureDefinitions[].FeatureName' "$current_schema_file" | sort | uniq -d | wc -l)
    if [ "$duplicate_count" -gt 0 ]; then
        echo "  ⚠️  중복된 feature 이름 발견!"
        jq -r '.FeatureDefinitions[].FeatureName' "$current_schema_file" | sort | uniq -d | sed 's/^/    - /'
    else
        echo "  ✅ 중복 feature 없음"
    fi
    
    # 필수 feature 확인
    record_identifier=$(jq -r '.RecordIdentifierFeatureName' "$current_schema_file")
    event_time_feature=$(jq -r '.EventTimeFeatureName' "$current_schema_file")
    
    if [ "$record_identifier" != "null" ] && [ "$event_time_feature" != "null" ]; then
        echo "  ✅ 필수 features 구성됨 (Record ID: $record_identifier, Event Time: $event_time_feature)"
    else
        echo "  ⚠️  필수 feature 설정 확인 필요"
    fi
    
    # 스키마 진화 권장사항
    echo ""
    echo "💡 스키마 진화 권장사항:"
    if [ "$current_feature_count" -gt 20 ]; then
        echo "  📦 Feature 수가 많습니다 ($current_feature_count개). 논리적 그룹핑 고려해보세요."
    fi
    
    vector_features=$(jq '[.FeatureDefinitions[] | select(.CollectionType == "List")] | length' "$current_schema_file")
    if [ "$vector_features" -gt 5 ]; then
        echo "  🧮 벡터 feature가 많습니다 ($vector_features개). 차원 최적화를 고려해보세요."
    fi
    
    echo "  📚 변경 이력을 문서화하여 팀과 공유하세요."
    echo "  🧪 새 feature 추가 전에는 항상 테스트 환경에서 검증하세요."
    
else
    echo "❌ 스키마 백업 실패"
    exit 1
fi

# 정리 작업 (30일 이상 된 백업 파일 정리)
find "$EVOLUTION_DIR/$FEATURE_GROUP" -name "schema_*.json" -type f -mtime +30 -delete 2>/dev/null || true

echo ""
echo "📁 스키마 진화 관리 완료"
echo "  백업 디렉토리: $EVOLUTION_DIR/$FEATURE_GROUP"
echo "  최신 스키마: $current_schema_file"
echo "  진화 계획: $evolution_plan"
```

### 3. Feature 호환성 검증 시스템

```bash
#!/bin/bash
# feature_compatibility_validator.sh - 새 feature 추가 전 호환성 검증

FEATURE_GROUP="$1"
NEW_FEATURES_FILE="$2"

if [ -z "$FEATURE_GROUP" ] || [ -z "$NEW_FEATURES_FILE" ]; then
    echo "사용법: $0 <feature-group-name> <new-features-file>"
    exit 1
fi

echo "🔬 Feature 호환성 검증 시작"
echo "Feature Group: $FEATURE_GROUP"
echo "새 Features 파일: $NEW_FEATURES_FILE"
echo ""

# 임시 파일들
current_schema="/tmp/${FEATURE_GROUP}_current_schema.json"
validation_report="/tmp/validation_report_$(date +%Y%m%d_%H%M%S).txt"

# 현재 스키마 가져오기
echo "📊 현재 스키마 조회 중..."
if ! fs schema "$FEATURE_GROUP" --format json > "$current_schema"; then
    echo "❌ 현재 스키마를 가져올 수 없습니다"
    exit 1
fi

# 새 features 파일 검증
echo "📝 새 features 파일 검증 중..."
if [ ! -f "$NEW_FEATURES_FILE" ]; then
    echo "❌ 새 features 파일을 찾을 수 없습니다: $NEW_FEATURES_FILE"
    exit 1
fi

# JSON 유효성 검사
if ! jq empty "$NEW_FEATURES_FILE" 2>/dev/null; then
    echo "❌ 새 features 파일이 유효한 JSON이 아닙니다"
    exit 1
fi

# Python을 사용한 상세 호환성 검증
python3 << EOF > "$validation_report"
import json
import sys
from datetime import datetime

print("🔬 Feature 호환성 검증 리포트")
print("=" * 60)
print(f"검증 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
print(f"Feature Group: $FEATURE_GROUP")
print(f"새 Features 파일: $NEW_FEATURES_FILE")
print("")

# 현재 스키마 로드
try:
    with open('$current_schema', 'r') as f:
        current_schema = json.load(f)
except Exception as e:
    print(f"❌ 현재 스키마 로드 실패: {e}")
    sys.exit(1)

# 새 features 로드
try:
    with open('$NEW_FEATURES_FILE', 'r') as f:
        new_features = json.load(f)
except Exception as e:
    print(f"❌ 새 features 파일 로드 실패: {e}")
    sys.exit(1)

# 기존 features 정보
existing_features = {f['FeatureName']: f for f in current_schema['FeatureDefinitions']}
existing_feature_names = set(existing_features.keys())

print(f"📊 기존 Feature 현황")
print("-" * 30)
print(f"총 Feature 수: {len(existing_features)}")
print(f"Record Identifier: {current_schema.get('RecordIdentifierFeatureName', 'N/A')}")
print(f"Event Time Feature: {current_schema.get('EventTimeFeatureName', 'N/A')}")

# 새 features 검증
print(f"\n📝 새 Features 검증")
print("-" * 30)

if not isinstance(new_features, list):
    print("❌ 새 features는 배열 형태여야 합니다")
    sys.exit(1)

print(f"추가 예정 Feature 수: {len(new_features)}")

# 상세 검증
validation_errors = []
validation_warnings = []
features_to_add = []
duplicate_features = []

for i, feature in enumerate(new_features):
    feature_name = feature.get('FeatureName')
    feature_type = feature.get('FeatureType')
    
    # 필수 필드 검증
    if not feature_name:
        validation_errors.append(f"Feature #{i+1}: FeatureName이 필요합니다")
        continue
        
    if not feature_type:
        validation_errors.append(f"Feature '{feature_name}': FeatureType이 필요합니다")
        continue
    
    # FeatureType 유효성 검증
    valid_types = ['String', 'Integral', 'Fractional']
    if feature_type not in valid_types:
        validation_errors.append(f"Feature '{feature_name}': 잘못된 FeatureType '{feature_type}'. 유효한 값: {valid_types}")
        continue
    
    # 중복 검사
    if feature_name in existing_feature_names:
        duplicate_features.append(feature_name)
        continue
    
    # CollectionType 검증
    collection_type = feature.get('CollectionType')
    if collection_type:
        if collection_type not in ['List', 'Set']:
            validation_errors.append(f"Feature '{feature_name}': 잘못된 CollectionType '{collection_type}'")
        elif collection_type == 'List':
            # VectorConfig 검증
            collection_config = feature.get('CollectionConfig', {})
            vector_config = collection_config.get('VectorConfig', {})
            dimension = vector_config.get('Dimension')
            
            if not dimension or not isinstance(dimension, int) or dimension <= 0:
                validation_errors.append(f"Feature '{feature_name}': List 타입은 유효한 Dimension이 필요합니다")
    
    # 이름 규칙 검증
    if not feature_name.replace('_', '').replace('-', '').isalnum():
        validation_warnings.append(f"Feature '{feature_name}': 이름에 특수문자가 포함되어 있습니다")
    
    if len(feature_name) > 64:
        validation_errors.append(f"Feature '{feature_name}': 이름이 너무 깁니다 (최대 64자)")
    
    features_to_add.append(feature)

# 검증 결과 출력
print(f"\n📋 검증 결과")
print("-" * 30)

if validation_errors:
    print(f"❌ 검증 오류 ({len(validation_errors)}개):")
    for error in validation_errors:
        print(f"  - {error}")
    print("")

if validation_warnings:
    print(f"⚠️  검증 경고 ({len(validation_warnings)}개):")
    for warning in validation_warnings:
        print(f"  - {warning}")
    print("")

if duplicate_features:
    print(f"🔄 중복된 Features ({len(duplicate_features)}개, 스킵됨):")
    for dup in duplicate_features:
        existing_type = existing_features[dup]['FeatureType']
        print(f"  - {dup} (기존: {existing_type})")
    print("")

if features_to_add:
    print(f"✅ 추가 가능한 Features ({len(features_to_add)}개):")
    for feature in features_to_add:
        fname = feature['FeatureName']
        ftype = feature['FeatureType']
        collection = feature.get('CollectionType', '')
        desc = feature.get('Description', '')
        
        collection_info = f" [{collection}]" if collection else ""
        desc_info = f" - {desc}" if desc else ""
        
        print(f"  + {fname} ({ftype}{collection_info}){desc_info}")
    print("")

# 호환성 분석
print(f"🔍 호환성 분석")
print("-" * 30)

# Feature 개수 분석
total_after_addition = len(existing_features) + len(features_to_add)
if total_after_addition > 50:
    print(f"⚠️  추가 후 총 Feature 수가 많습니다 ({total_after_addition}개)")
    print("   → Feature Group 분할을 고려해보세요")

# 벡터 feature 분석
vector_features_existing = sum(1 for f in existing_features.values() if f.get('CollectionType') == 'List')
vector_features_new = sum(1 for f in features_to_add if f.get('CollectionType') == 'List')
total_vectors = vector_features_existing + vector_features_new

if total_vectors > 10:
    print(f"⚠️  벡터 Feature가 많습니다 ({total_vectors}개)")
    print("   → 스토리지 및 쿼리 성능에 영향을 줄 수 있습니다")

# 타입 분포 분석
type_distribution = {}
for feature in list(existing_features.values()) + features_to_add:
    ftype = feature.get('FeatureType', 'Unknown')
    type_distribution[ftype] = type_distribution.get(ftype, 0) + 1

print(f"\n📊 Feature Type 분포 (추가 후):")
for ftype, count in type_distribution.items():
    print(f"  {ftype}: {count}개")

# 권장사항
print(f"\n💡 권장사항")
print("-" * 30)

if validation_errors:
    print("1. 검증 오류를 모두 수정한 후 다시 시도하세요")
    sys.exit(1)  # 오류가 있으면 실패로 종료
else:
    print("✅ 호환성 검증 통과!")
    
    if validation_warnings:
        print("2. 경고 사항을 검토하고 필요시 수정하세요")
    
    print("3. 테스트 환경에서 먼저 검증하세요")
    print("4. 새 feature 추가 후 스키마 백업을 권장합니다")
    
    if len(features_to_add) > 0:
        print("\n🚀 다음 명령어로 Feature를 추가할 수 있습니다:")
        print(f"   fs add-features $FEATURE_GROUP $NEW_FEATURES_FILE --dry-run")
        print(f"   fs add-features $FEATURE_GROUP $NEW_FEATURES_FILE")
EOF

# 검증 리포트 표시
echo ""
cat "$validation_report"

# 리포트 저장 여부 확인
echo ""
echo "📄 검증 리포트를 저장하시겠습니까? (y/N)"
read -r save_report

if [[ $save_report =~ ^[Yy]$ ]]; then
    report_dir="validation_reports"
    mkdir -p "$report_dir"
    
    final_report="$report_dir/${FEATURE_GROUP}_compatibility_$(date +%Y%m%d_%H%M%S).txt"
    cp "$validation_report" "$final_report"
    
    echo "✅ 검증 리포트 저장됨: $final_report"
fi

# 정리
rm -f "$current_schema" "$validation_report"

echo ""
echo "🔬 호환성 검증 완료"
```

### 4. 스마트 Feature 추천 시스템

```bash
#!/bin/bash
# smart_feature_recommender.sh - ML 기반 새 feature 추천

FEATURE_GROUP="$1"
RECOMMENDATION_TYPE="${2:-analytics}"  # analytics, ml, business

if [ -z "$FEATURE_GROUP" ]; then
    echo "사용법: $0 <feature-group-name> [recommendation-type]"
    echo "recommendation-type: analytics, ml, business"
    exit 1
fi

echo "🤖 스마트 Feature 추천 시스템"
echo "Feature Group: $FEATURE_GROUP"
echo "추천 유형: $RECOMMENDATION_TYPE"
echo ""

# 현재 스키마 분석
current_schema="/tmp/${FEATURE_GROUP}_analysis.json"
echo "📊 현재 Feature Group 분석 중..."

if ! fs schema "$FEATURE_GROUP" --format json > "$current_schema"; then
    echo "❌ Feature Group 스키마를 가져올 수 없습니다"
    exit 1
fi

# Python 기반 추천 시스템
python3 << EOF
import json
import re
from datetime import datetime
from collections import defaultdict

# 추천 템플릿
RECOMMENDATION_TEMPLATES = {
    'analytics': {
        'temporal_features': [
            {
                "FeatureName": "created_timestamp",
                "FeatureType": "Fractional",
                "Description": "레코드 생성 시간 (Unix timestamp)",
                "rationale": "시계열 분석 및 트렌드 파악에 필수"
            },
            {
                "FeatureName": "last_updated_date",
                "FeatureType": "String", 
                "Description": "마지막 업데이트 날짜 (YYYY-MM-DD)",
                "rationale": "데이터 신선도 및 업데이트 패턴 분석"
            },
            {
                "FeatureName": "hour_of_day",
                "FeatureType": "Integral",
                "Description": "하루 중 시간 (0-23)",
                "rationale": "시간별 패턴 분석"
            }
        ],
        'quality_features': [
            {
                "FeatureName": "data_quality_score",
                "FeatureType": "Fractional", 
                "Description": "데이터 품질 점수 (0.0-1.0)",
                "rationale": "데이터 신뢰성 평가 및 필터링"
            },
            {
                "FeatureName": "completeness_ratio",
                "FeatureType": "Fractional",
                "Description": "필드 완성도 비율",
                "rationale": "누락 데이터 분석"
            }
        ],
        'aggregation_features': [
            {
                "FeatureName": "daily_count",
                "FeatureType": "Integral",
                "Description": "일별 발생 횟수",
                "rationale": "활동량 추이 분석"
            },
            {
                "FeatureName": "cumulative_value",
                "FeatureType": "Fractional",
                "Description": "누적 값",
                "rationale": "성장 및 누적 패턴 분석"
            }
        ]
    },
    'ml': {
        'embedding_features': [
            {
                "FeatureName": "text_embeddings",
                "FeatureType": "String",
                "CollectionType": "List",
                "CollectionConfig": {
                    "VectorConfig": {"Dimension": 512}
                },
                "Description": "텍스트 임베딩 벡터",
                "rationale": "자연어 처리 모델의 입력 feature"
            },
            {
                "FeatureName": "item_embeddings", 
                "FeatureType": "String",
                "CollectionType": "List",
                "CollectionConfig": {
                    "VectorConfig": {"Dimension": 256}
                },
                "Description": "아이템 임베딩 벡터",
                "rationale": "추천 시스템 및 유사도 계산"
            }
        ],
        'engineered_features': [
            {
                "FeatureName": "interaction_score",
                "FeatureType": "Fractional",
                "Description": "상호작용 점수",
                "rationale": "ML 모델의 예측력 향상"
            },
            {
                "FeatureName": "anomaly_score",
                "FeatureType": "Fractional", 
                "Description": "이상치 점수",
                "rationale": "이상 탐지 모델 학습"
            },
            {
                "FeatureName": "feature_importance_weights",
                "FeatureType": "String",
                "CollectionType": "List", 
                "CollectionConfig": {
                    "VectorConfig": {"Dimension": 100}
                },
                "Description": "Feature 중요도 가중치",
                "rationale": "동적 feature selection"
            }
        ],
        'prediction_features': [
            {
                "FeatureName": "predicted_value",
                "FeatureType": "Fractional",
                "Description": "예측값",
                "rationale": "모델 출력 저장 및 비교"
            },
            {
                "FeatureName": "prediction_confidence",
                "FeatureType": "Fractional",
                "Description": "예측 신뢰도",
                "rationale": "예측 품질 평가"
            }
        ]
    },
    'business': {
        'kpi_features': [
            {
                "FeatureName": "conversion_rate",
                "FeatureType": "Fractional",
                "Description": "전환율",
                "rationale": "비즈니스 성과 측정"
            },
            {
                "FeatureName": "lifetime_value",
                "FeatureType": "Fractional", 
                "Description": "고객 생애 가치",
                "rationale": "고객 세분화 및 마케팅 최적화"
            },
            {
                "FeatureName": "retention_score",
                "FeatureType": "Fractional",
                "Description": "고객 유지 점수", 
                "rationale": "이탈 예측 모델 개발"
            }
        ],
        'segmentation_features': [
            {
                "FeatureName": "customer_segment",
                "FeatureType": "String",
                "Description": "고객 세그먼트 분류",
                "rationale": "타겟 마케팅 및 개인화"
            },
            {
                "FeatureName": "engagement_level",
                "FeatureType": "String", 
                "Description": "참여도 수준 (High/Medium/Low)",
                "rationale": "참여도 기반 전략 수립"
            }
        ],
        'financial_features': [
            {
                "FeatureName": "revenue_contribution",
                "FeatureType": "Fractional",
                "Description": "매출 기여도",
                "rationale": "수익성 분석"
            },
            {
                "FeatureName": "cost_per_acquisition",
                "FeatureType": "Fractional",
                "Description": "고객 획득 비용",
                "rationale": "마케팅 ROI 최적화"
            }
        ]
    }
}

# 현재 스키마 로드
with open('$current_schema', 'r') as f:
    schema = json.load(f)

existing_features = {f['FeatureName'].lower() for f in schema['FeatureDefinitions']}
feature_types = defaultdict(int)
has_vector_features = False

# 기존 feature 분석
for feature in schema['FeatureDefinitions']:
    feature_types[feature['FeatureType']] += 1
    if feature.get('CollectionType') == 'List':
        has_vector_features = True

print(f"🧠 스마트 Feature 추천 리포트")
print(f"=" * 60)
print(f"생성 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
print(f"Feature Group: $FEATURE_GROUP")
print(f"추천 유형: $RECOMMENDATION_TYPE")
print(f"")

print(f"📊 현재 Feature 분석")
print(f"-" * 30)
print(f"총 Feature 수: {len(existing_features)}")
print(f"Feature Type 분포:")
for ftype, count in feature_types.items():
    print(f"  - {ftype}: {count}개")
print(f"벡터 Feature 존재: {'예' if has_vector_features else '아니오'}")
print("")

# 추천 생성
recommendations = RECOMMENDATION_TEMPLATES.get('$RECOMMENDATION_TYPE', {})
if not recommendations:
    print("❌ 잘못된 추천 유형입니다")
    exit(1)

recommended_features = []
recommendation_reasons = []

print(f"🎯 추천 Feature (유형: $RECOMMENDATION_TYPE)")
print(f"-" * 30)

for category, features in recommendations.items():
    category_name = category.replace('_', ' ').title()
    print(f"\n📂 {category_name}:")
    
    category_recommendations = []
    for feature in features:
        feature_name_lower = feature['FeatureName'].lower()
        
        # 이미 존재하는 feature는 제외
        if feature_name_lower not in existing_features:
            # 유사한 이름의 feature가 있는지 확인
            similar_exists = any(
                feature_name_lower in existing.lower() or existing.lower() in feature_name_lower 
                for existing in existing_features
            )
            
            if not similar_exists:
                category_recommendations.append(feature)
                recommended_features.append(feature)
                
                print(f"  + {feature['FeatureName']} ({feature['FeatureType']})")
                if feature.get('CollectionType'):
                    print(f"    Collection: {feature['CollectionType']}")
                print(f"    설명: {feature['Description']}")
                print(f"    근거: {feature['rationale']}")
                print("")
    
    if not category_recommendations:
        print(f"  ℹ️ 이 카테고리의 feature들은 이미 존재하거나 유사합니다")

# 개별화된 추천 (feature 이름 패턴 기반)
print(f"\n🎨 개별화된 추천 (기존 패턴 기반)")
print(f"-" * 40)

# 기존 feature 이름에서 패턴 추출
name_patterns = []
for feature in schema['FeatureDefinitions']:
    name = feature['FeatureName'].lower()
    
    # 공통 패턴 찾기
    if 'user' in name or 'customer' in name:
        if 'user_satisfaction_score' not in [f['FeatureName'].lower() for f in recommended_features]:
            recommended_features.append({
                "FeatureName": "user_satisfaction_score",
                "FeatureType": "Fractional",
                "Description": "사용자 만족도 점수",
                "rationale": "기존 사용자 관련 feature들과 연계한 만족도 측정"
            })
    
    if 'price' in name or 'cost' in name or 'amount' in name:
        if 'price_elasticity' not in [f['FeatureName'].lower() for f in recommended_features]:
            recommended_features.append({
                "FeatureName": "price_elasticity",
                "FeatureType": "Fractional", 
                "Description": "가격 탄력성 지수",
                "rationale": "가격 관련 feature들과 연계한 탄력성 분석"
            })
    
    if 'time' in name or 'date' in name:
        if 'time_since_last_activity' not in [f['FeatureName'].lower() for f in recommended_features]:
            recommended_features.append({
                "FeatureName": "time_since_last_activity",
                "FeatureType": "Fractional",
                "Description": "마지막 활동 이후 경과 시간 (시간 단위)",
                "rationale": "시간 관련 feature들과 연계한 활동 패턴 분석"
            })

# 최종 추천 요약
print(f"\n📋 추천 요약")
print(f"-" * 30)
print(f"총 추천 Feature 수: {len(recommended_features)}")

if not recommended_features:
    print("현재 Feature Group이 이미 충분히 구성되어 있습니다.")
    print("특별한 요구사항이 있다면 수동으로 feature를 추가해보세요.")
else:
    # 추천 feature들을 JSON 파일로 생성
    output_file = f"recommended_features_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
    
    # Description과 rationale 제거하고 순수 feature definition만 남김
    clean_features = []
    for feature in recommended_features:
        clean_feature = {
            "FeatureName": feature["FeatureName"],
            "FeatureType": feature["FeatureType"]
        }
        if "CollectionType" in feature:
            clean_feature["CollectionType"] = feature["CollectionType"]
        if "CollectionConfig" in feature:
            clean_feature["CollectionConfig"] = feature["CollectionConfig"]
        if "Description" in feature:
            clean_feature["Description"] = feature["Description"]
        
        clean_features.append(clean_feature)
    
    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump(clean_features, f, indent=2, ensure_ascii=False)
    
    print(f"✅ 추천 feature 파일 생성됨: {output_file}")
    print(f"")
    print(f"🚀 다음 단계:")
    print(f"1. 추천 내용을 검토하고 필요에 따라 수정")
    print(f"2. 호환성 검증: feature_compatibility_validator.sh $FEATURE_GROUP {output_file}")
    print(f"3. Feature 추가: fs add-features $FEATURE_GROUP {output_file} --dry-run")
    print(f"4. 실제 적용: fs add-features $FEATURE_GROUP {output_file}")

EOF

echo ""
echo "🤖 스마트 추천 완료"

# 정리
rm -f "$current_schema"
```

### 5. A/B 테스트를 위한 점진적 Feature 롤아웃

```bash
#!/bin/bash
# progressive_feature_rollout.sh - 점진적 feature 배포 시스템

FEATURE_GROUP="$1"
FEATURES_FILE="$2"
ROLLOUT_STRATEGY="${3:-canary}"  # canary, blue-green, percentage

if [ -z "$FEATURE_GROUP" ] || [ -z "$FEATURES_FILE" ]; then
    echo "사용법: $0 <feature-group-name> <features-file> [rollout-strategy]"
    echo "rollout-strategy: canary, blue-green, percentage"
    exit 1
fi

echo "🚀 점진적 Feature 롤아웃 시스템"
echo "Feature Group: $FEATURE_GROUP"
echo "Features 파일: $FEATURES_FILE"
echo "롤아웃 전략: $ROLLOUT_STRATEGY"
echo ""

# 롤아웃 디렉토리 생성
rollout_dir="feature_rollouts/$(date +%Y%m%d_%H%M%S)_${FEATURE_GROUP}"
mkdir -p "$rollout_dir"

# 현재 상태 백업
echo "💾 현재 스키마 백업 중..."
fs schema "$FEATURE_GROUP" --format json > "$rollout_dir/schema_before.json"

# 롤아웃 계획 생성
rollout_plan="$rollout_dir/rollout_plan.json"

cat > "$rollout_plan" << EOF
{
  "rollout_id": "$(date +%Y%m%d_%H%M%S)",
  "feature_group": "$FEATURE_GROUP", 
  "features_file": "$FEATURES_FILE",
  "strategy": "$ROLLOUT_STRATEGY",
  "start_time": "$(date -Iseconds)",
  "stages": [],
  "current_stage": 0,
  "status": "planned"
}
EOF

case "$ROLLOUT_STRATEGY" in
    "canary")
        echo "🐦 Canary 롤아웃 전략 적용"
        echo ""
        
        # Stage 1: 검증만 (실제 배포 안함)
        echo "📋 Stage 1: Canary 검증"
        echo "  - 호환성 검증"
        echo "  - Dry-run 테스트" 
        echo "  - 영향도 분석"
        
        # 호환성 검증
        if ./feature_compatibility_validator.sh "$FEATURE_GROUP" "$FEATURES_FILE"; then
            echo "  ✅ 호환성 검증 통과"
        else
            echo "  ❌ 호환성 검증 실패 - 롤아웃 중단"
            exit 1
        fi
        
        # Dry-run
        if fs add-features "$FEATURE_GROUP" "$FEATURES_FILE" --dry-run; then
            echo "  ✅ Dry-run 테스트 통과"
        else
            echo "  ❌ Dry-run 테스트 실패 - 롤아웃 중단"
            exit 1
        fi
        
        echo ""
        echo "⏸️  Canary 검증 완료. 계속하시겠습니까? (y/N)"
        read -r continue_rollout
        
        if [[ ! $continue_rollout =~ ^[Yy]$ ]]; then
            echo "🛑 롤아웃 취소됨"
            exit 0
        fi
        
        # Stage 2: 실제 배포
        echo "📋 Stage 2: 프로덕션 배포"
        
        if fs add-features "$FEATURE_GROUP" "$FEATURES_FILE"; then
            echo "  ✅ Feature 추가 성공"
            
            # 배포 후 검증
            echo "  🔍 배포 후 검증 중..."
            fs schema "$FEATURE_GROUP" --format json > "$rollout_dir/schema_after.json"
            
            # 변경 사항 확인
            python3 << 'EOF'
import json

with open('$rollout_dir/schema_before.json', 'r') as f:
    before = json.load(f)
with open('$rollout_dir/schema_after.json', 'r') as f:
    after = json.load(f)

before_features = {f['FeatureName'] for f in before['FeatureDefinitions']}
after_features = {f['FeatureName'] for f in after['FeatureDefinitions']}

new_features = after_features - before_features
print(f"  📈 추가된 features: {len(new_features)}개")
for feature in sorted(new_features):
    print(f"    + {feature}")
EOF
            
            echo "  ✅ Canary 롤아웃 성공 완료"
        else
            echo "  ❌ Feature 추가 실패"
            exit 1
        fi
        ;;
        
    "blue-green")
        echo "🔵🟢 Blue-Green 롤아웃 전략"
        echo "⚠️  참고: SageMaker Feature Store는 Blue-Green을 직접 지원하지 않습니다."
        echo "대신 Feature 추가 전후 비교를 통한 안전한 배포를 수행합니다."
        echo ""
        
        # Green (새 버전) 준비
        echo "📋 Green 환경 준비"
        
        # 백업 Feature Group 생성은 비용이 많이 들므로, 메타데이터로 시뮬레이션
        green_metadata="$rollout_dir/green_environment.json"
        
        # 현재 schema에 새 features 추가한 시뮬레이션
        python3 << 'EOF'
import json

# 현재 스키마 로드
with open('$rollout_dir/schema_before.json', 'r') as f:
    current_schema = json.load(f)

# 새 features 로드  
with open('$FEATURES_FILE', 'r') as f:
    new_features = json.load(f)

# Green 환경 스키마 시뮬레이션
green_schema = current_schema.copy()
green_schema['FeatureDefinitions'].extend(new_features)
green_schema['TotalFeatures'] = len(green_schema['FeatureDefinitions'])

# Green 메타데이터 저장
green_metadata = {
    "environment": "green",
    "simulated_schema": green_schema,
    "deployment_time": "$(date -Iseconds)",
    "rollback_available": True
}

with open('$rollout_dir/green_environment.json', 'w') as f:
    json.dump(green_metadata, f, indent=2, ensure_ascii=False, default=str)

print("  ✅ Green 환경 메타데이터 준비 완료")
print(f"  📊 예상 total features: {green_schema['TotalFeatures']}")
EOF
        
        echo ""
        echo "⏸️  Green 환경으로 전환하시겠습니까? (y/N)"
        read -r switch_to_green
        
        if [[ ! $switch_to_green =~ ^[Yy]$ ]]; then
            echo "🛑 Blue-Green 롤아웃 취소됨"
            exit 0
        fi
        
        # Green으로 전환 (실제 Feature 추가)
        echo "📋 Green 환경으로 전환"
        
        if fs add-features "$FEATURE_GROUP" "$FEATURES_FILE"; then
            echo "  ✅ Green 환경 배포 성공"
            
            # 새 환경 상태 저장
            fs schema "$FEATURE_GROUP" --format json > "$rollout_dir/green_deployed.json"
            
            echo "  🔍 트래픽 전환 완료"
            echo "  ✅ Blue-Green 롤아웃 완료"
        else
            echo "  ❌ Green 환경 배포 실패"
            exit 1
        fi
        ;;
        
    "percentage")
        echo "📊 Percentage 기반 점진적 롤아웃"
        echo "⚠️  참고: 이는 Feature 추가를 단계별로 진행하는 시뮬레이션입니다."
        echo ""
        
        # Features를 그룹으로 나누기
        total_features=$(jq length "$FEATURES_FILE")
        
        if [ "$total_features" -lt 2 ]; then
            echo "🔄 Feature가 적어서 전체 배포로 진행합니다"
            fs add-features "$FEATURE_GROUP" "$FEATURES_FILE"
        else
            echo "📊 $total_features개 features를 단계별로 배포합니다"
            
            # 20%, 50%, 100% 단계로 배포
            stages=(20 50 100)
            
            for stage_percent in "${stages[@]}"; do
                features_count=$(( (total_features * stage_percent) / 100 ))
                if [ $features_count -eq 0 ]; then
                    features_count=1
                fi
                
                echo ""
                echo "📋 Stage: ${stage_percent}% ($features_count개 features)"
                
                # 해당 단계의 features만 추출
                stage_features="$rollout_dir/stage_${stage_percent}_features.json"
                jq ".[0:$features_count]" "$FEATURES_FILE" > "$stage_features"
                
                echo "  🚀 ${stage_percent}% 배포 시작..."
                
                if fs add-features "$FEATURE_GROUP" "$stage_features"; then
                    echo "  ✅ ${stage_percent}% 배포 성공"
                    
                    # 각 단계 후 상태 저장
                    fs schema "$FEATURE_GROUP" --format json > "$rollout_dir/schema_stage_${stage_percent}.json"
                    
                    if [ "$stage_percent" -lt 100 ]; then
                        echo "  ⏸️  다음 단계로 계속하시겠습니까? (y/N)"
                        read -r continue_next_stage
                        
                        if [[ ! $continue_next_stage =~ ^[Yy]$ ]]; then
                            echo "🛑 ${stage_percent}%에서 롤아웃 중단됨"
                            break
                        fi
                    fi
                else
                    echo "  ❌ ${stage_percent}% 배포 실패"
                    exit 1
                fi
            done
            
            echo "  ✅ 점진적 롤아웃 완료"
        fi
        ;;
        
    *)
        echo "❌ 지원하지 않는 롤아웃 전략: $ROLLOUT_STRATEGY"
        echo "지원 전략: canary, blue-green, percentage"
        exit 1
        ;;
esac

# 롤아웃 완료 리포트
echo ""
echo "📄 롤아웃 완료 리포트"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

# 롤아웃 정보 업데이트
jq ".status = \"completed\" | .end_time = \"$(date -Iseconds)\"" "$rollout_plan" > "${rollout_plan}.tmp" && mv "${rollout_plan}.tmp" "$rollout_plan"

echo "롤아웃 ID: $(jq -r '.rollout_id' "$rollout_plan")"
echo "전략: $(jq -r '.strategy' "$rollout_plan")"
echo "시작 시간: $(jq -r '.start_time' "$rollout_plan")"
echo "완료 시간: $(jq -r '.end_time' "$rollout_plan")"

# 변경 요약
if [ -f "$rollout_dir/schema_before.json" ] && [ -f "$rollout_dir/schema_after.json" ]; then
    before_count=$(jq '.TotalFeatures' "$rollout_dir/schema_before.json")
    after_count=$(jq '.TotalFeatures' "$rollout_dir/schema_after.json")
    added_count=$((after_count - before_count))
    
    echo "변경 요약:"
    echo "  배포 전 features: $before_count개"
    echo "  배포 후 features: $after_count개"  
    echo "  추가된 features: $added_count개"
fi

echo "롤아웃 아티팩트: $rollout_dir"

# 롤백 스크립트 생성
rollback_script="$rollout_dir/rollback.sh"
cat > "$rollback_script" << 'ROLLBACK_EOF'
#!/bin/bash
# 자동 생성된 롤백 스크립트
echo "⚠️  경고: SageMaker Feature Store는 feature 제거를 지원하지 않습니다."
echo "롤백은 새로운 Feature Group 생성으로만 가능합니다."
echo ""
echo "롤백 옵션:"
echo "1. 새 Feature Group을 이전 스키마로 생성"
echo "2. 데이터를 새 Feature Group으로 마이그레이션"
echo "3. 애플리케이션 설정 업데이트"
echo ""
echo "이전 스키마: $rollout_dir/schema_before.json"
ROLLBACK_EOF

chmod +x "$rollback_script"

echo ""
echo "🔙 롤백 정보:"
echo "  ⚠️  Feature 제거는 지원되지 않습니다"
echo "  📄 롤백 안내: $rollback_script"
echo "  💾 이전 스키마: $rollout_dir/schema_before.json"

echo ""
echo "🎉 점진적 Feature 롤아웃 완료!"
```

## 성능 최적화

### 대용량 Feature 추가 최적화

```bash
#!/bin/bash
# optimize_large_feature_additions.sh

optimize_feature_addition() {
    local feature_group=$1
    local features_file=$2
    
    echo "⚡ 대용량 Feature 추가 최적화"
    
    # Feature 수 확인
    feature_count=$(jq 'length' "$features_file")
    
    if [ "$feature_count" -gt 10 ]; then
        echo "📊 많은 수의 features 감지 ($feature_count개)"
        echo "최적화된 배치 처리를 적용합니다."
        
        # 5개씩 배치로 나누어 처리
        batch_size=5
        batches=$(( (feature_count + batch_size - 1) / batch_size ))
        
        echo "🔄 $batches개 배치로 처리합니다 (배치당 $batch_size개)"
        
        for ((i=0; i<batches; i++)); do
            start_index=$((i * batch_size))
            batch_file="/tmp/batch_${i}_features.json"
            
            jq ".[${start_index}:${start_index}+${batch_size}]" "$features_file" > "$batch_file"
            
            echo "📦 배치 $((i+1))/$batches 처리 중..."
            
            if fs add-features "$feature_group" "$batch_file" --no-wait; then
                echo "✅ 배치 $((i+1)) 성공"
                
                # 다음 배치 전에 잠시 대기 (API 제한 고려)
                if [ $((i+1)) -lt $batches ]; then
                    echo "⏳ API 제한 고려한 대기 (30초)..."
                    sleep 30
                fi
            else
                echo "❌ 배치 $((i+1)) 실패"
                return 1
            fi
            
            rm -f "$batch_file"
        done
        
        echo "⏳ 모든 배치 완료 대기 중..."
        # 마지막에 한 번만 완료 대기
        while true; do
            status=$(aws sagemaker describe-feature-group \
                    --feature-group-name "$feature_group" \
                    --query 'FeatureGroupStatus' --output text)
            
            if [ "$status" = "Created" ]; then
                echo "✅ 모든 Feature 추가 완료"
                break
            elif [ "$status" = "UpdateFailed" ]; then
                echo "❌ Feature 업데이트 실패"
                return 1
            else
                echo "현재 상태: $status (대기 중...)"
                sleep 15
            fi
        done
    else
        echo "📊 적은 수의 features로 일반 처리합니다"
        fs add-features "$feature_group" "$features_file"
    fi
}
```

## 트러블슈팅

### 일반적인 오류들

```bash
# Feature 추가 실패
❌ AWS 오류 (ValidationException): Feature name already exists
# 해결: 기존 feature 이름과 중복 확인

# 잘못된 FeatureType
❌ 검증 오류: Invalid FeatureType 'Integer'. Valid values: ['String', 'Integral', 'Fractional']
# 해결: FeatureType을 'Integral'로 수정

# 벡터 차원 누락
❌ Feature 'embeddings': List 타입은 유효한 Dimension이 필요합니다
# 해결: CollectionConfig.VectorConfig.Dimension 설정

# Feature Group 없음
❌ Feature Group 'non-existent'을 찾을 수 없습니다
# 해결: Feature Group 이름 확인 또는 생성
```

### 복구 및 재시도

```bash
#!/bin/bash
# feature_addition_recovery.sh

recovery_add_features() {
    local feature_group=$1
    local features_file=$2
    local max_retries=${3:-3}
    
    echo "🔄 Feature 추가 복구 시스템"
    
    for attempt in $(seq 1 $max_retries); do
        echo "시도 $attempt/$max_retries..."
        
        if fs add-features "$feature_group" "$features_file"; then
            echo "✅ $attempt번째 시도 성공"
            return 0
        else
            echo "❌ $attempt번째 시도 실패"
            
            if [ $attempt -lt $max_retries ]; then
                wait_time=$((attempt * 30))
                echo "⏳ ${wait_time}초 대기 후 재시도..."
                sleep $wait_time
            fi
        fi
    done
    
    echo "💥 모든 재시도 실패"
    return 1
}
```

## 방식별 비교 및 선택 가이드

### 언제 어떤 방식을 사용할까?

| 상황 | 권장 방식 | 이유 |
|------|---------|-----|
| **빠른 프로토타이핑** | CLI 플래그 방식 (`add-feature`) | 즉석에서 테스트하기 쉽고 간단함 |
| **복잡한 벡터 Feature** | JSON 문자열 방식 (`add-feature-json`) | 복잡한 설정을 정확하게 표현 가능 |
| **대량 Feature 추가** | JSON 파일 방식 (`add-features`) | 파일 관리, 버전 관리, 재사용 용이 |
| **스크립트 자동화** | CLI 플래그 방식 | 동적으로 생성하기 쉬움 |
| **문서화가 중요한 경우** | JSON 파일 방식 | 스키마 설명과 주석 포함 가능 |
| **CI/CD 파이프라인** | JSON 파일 방식 | 버전 관리 및 리뷰 프로세스 적합 |

### 실무 활용 패턴

#### 1. 개발 단계별 접근법
```bash
# 1단계: 프로토타이핑 (CLI 플래그)
fs add-feature test-features -f "prototype_score:Fractional" --dry-run

# 2단계: 정교화 (JSON 문자열)
fs add-feature-json test-features \
  -j '{"FeatureName": "refined_score", "FeatureType": "Fractional", "Description": "정제된 점수 로직"}'

# 3단계: 프로덕션 (JSON 파일)
fs add-features prod-features production_features.json
```

#### 2. 팀 협업 워크플로우
```bash
# 개발자: 빠른 실험
fs add-feature dev-fg -f "experiment_metric:Fractional:실험용 지표"

# 리뷰 후: 구조화된 추가
cat > team_features.json << EOF
[
  {
    "FeatureName": "experiment_metric_v2", 
    "FeatureType": "Fractional",
    "Description": "검증된 실험 지표 (팀 리뷰 완료)"
  }
]
EOF

fs add-features prod-fg team_features.json
```

### 성능 최적화 팁

#### Feature 추가 순서 최적화
```bash
# ❌ 비효율적: 하나씩 개별 추가
fs add-feature fg -f "metric1:Fractional" 
fs add-feature fg -f "metric2:Integral"
fs add-feature fg -f "metric3:String"

# ✅ 효율적: 배치로 함께 추가  
fs add-feature fg \
  -f "metric1:Fractional" \
  -f "metric2:Integral" \
  -f "metric3:String"
```

#### 대용량 처리 전략
```bash
# 10개 이상의 feature는 배치 분할
FEATURES=(
  "metric1:Fractional" "metric2:Integral" "metric3:String"
  "metric4:Fractional" "metric5:String" "metric6:Integral"
  # ... 더 많은 features
)

# 5개씩 배치 처리
BATCH_SIZE=5
for ((i=0; i<${#FEATURES[@]}; i+=BATCH_SIZE)); do
  batch=(${FEATURES[@]:i:BATCH_SIZE})
  echo "배치 $((i/BATCH_SIZE + 1)) 처리 중..."
  
  fs add-feature my-fg $(printf " -f %s" "${batch[@]}") --no-wait
  
  # API 제한 고려한 딜레이
  sleep 10
done
```

## 모범 사례 (Best Practices)

### 1. Feature 이름 규칙
```bash
# ✅ 좋은 예시
fs add-feature ecommerce-fg \
  -f "user_lifetime_value:Fractional:고객 생애 가치 (USD)" \
  -f "product_category_preferences:String:set:선호 상품 카테고리" \
  -f "purchase_behavior_embedding:String:list:256:구매 행동 임베딩"

# ❌ 피해야 할 예시  
fs add-feature ecommerce-fg \
  -f "LTV:Fractional" \           # 약어 사용
  -f "prefs:String:set" \         # 불명확한 이름
  -f "emb:String:list:256"        # 설명 없음
```

### 2. 점진적 스키마 진화
```bash
# Phase 1: 기본 Analytics
fs add-feature analytics-fg \
  -f "page_views:Integral:페이지 뷰 수" \
  -f "session_duration:Integral:세션 지속시간(초)"

# Phase 2: 고급 Analytics (나중에 추가)
fs add-feature analytics-fg \
  -f "user_engagement_score:Fractional:사용자 참여도 점수" \
  -f "content_interaction_vector:String:list:128:콘텐츠 상호작용 벡터"

# Phase 3: ML Features (최종 단계)
fs add-feature analytics-fg \
  -f "predicted_conversion_probability:Fractional:전환 예측 확률" \
  -f "anomaly_detection_score:Fractional:이상 탐지 점수"
```

### 3. 환경별 관리
```bash
# 개발 환경
fs add-feature dev-features \
  -f "debug_score:Fractional:디버그용 점수" \
  -f "test_flag:String:테스트 플래그"

# 스테이징 환경  
fs add-feature staging-features \
  -f "validation_score:Fractional:검증용 점수" \
  -f "quality_metric:Fractional:품질 지표"

# 프로덕션 환경
fs add-features prod-features production_schema.json
```

## 문제 해결 가이드

### 자주 발생하는 오류와 해결책

| 오류 | 해결 방법 |
|------|---------|
| `Feature name already exists` | 기존 feature와 이름 중복 → schema 명령으로 확인 후 다른 이름 사용 |
| `Invalid FeatureType` | FeatureType 오타 → `String`, `Integral`, `Fractional` 중 사용 |
| `List type requires Dimension` | 벡터 feature의 dimension 누락 → `name:String:list:128` 형식으로 수정 |
| `벡터(List) 타입 feature는 Iceberg 테이블 형식에서만 지원됩니다` | Glue 테이블에 벡터 추가 시도 → Iceberg 형식 Feature Group 사용 또는 벡터 feature 제거 |
| `JSON parsing error` | JSON 문법 오류 → JSON validator로 검증 후 수정 |
| `Feature Group not found` | Feature Group 존재하지 않음 → `fs list`로 확인 후 올바른 이름 사용 |

### 복구 전략
```bash
#!/bin/bash
# feature_recovery.sh - Feature 추가 실패 시 복구

FEATURE_GROUP="$1"
BACKUP_SCHEMA="backup_schema_$(date +%Y%m%d).json"

echo "🔄 Feature 추가 복구 시스템"

# 1. 현재 상태 백업
echo "💾 현재 스키마 백업..."
fs schema "$FEATURE_GROUP" --format json > "$BACKUP_SCHEMA"

# 2. 상태 확인
echo "📊 Feature Group 상태 확인..."
fs schema "$FEATURE_GROUP" --format table

# 3. 재시도 로직
retry_add_features() {
    local max_attempts=3
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        echo "🔄 시도 $attempt/$max_attempts..."
        
        if fs add-features "$FEATURE_GROUP" "$2"; then
            echo "✅ 복구 성공!"
            return 0
        fi
        
        echo "❌ 시도 $attempt 실패"
        attempt=$((attempt + 1))
        
        if [ $attempt -le $max_attempts ]; then
            echo "⏳ 30초 대기 후 재시도..."
            sleep 30
        fi
    done
    
    echo "💥 모든 복구 시도 실패"
    echo "📄 백업 파일: $BACKUP_SCHEMA"
    return 1
}
```

## 관련 명령어

- [`schema`](13.schema.md) - Feature Group 스키마 조회
- [`schema-template`](14.schema-template.md) - Feature definition 템플릿 생성  
- [`list`](01.list.md) - Feature Group 목록 확인
- [`create`](02.create.md) - 새 Feature Group 생성

## 참고사항

- **불가역적 변경**: 추가된 feature는 제거할 수 없습니다
- **스키마 진화**: 기존 데이터와의 호환성을 항상 고려해야 합니다  
- **성능 영향**: 많은 수의 feature 추가는 쿼리 성능에 영향을 줄 수 있습니다
- **비용 고려**: 벡터 feature는 스토리지 비용이 많이 듭니다
- **API 제한**: AWS API 호출 제한을 고려하여 적절한 딜레이를 두세요
- **백업 권장**: 스키마 변경 전 항상 현재 상태를 백업하세요