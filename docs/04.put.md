# 4. put - 단일 레코드 저장

## 개요
Feature Group에 단일 레코드를 저장하거나 업데이트합니다.

## 기본 사용법
```bash
fs put FEATURE_GROUP_NAME --record 'JSON_RECORD' [OPTIONS]
```

## 필수 인자
- `FEATURE_GROUP_NAME`: 저장할 Feature Group 이름
- `--record TEXT`: 저장할 레코드의 JSON 문자열 (필수)

## 상세 사용 예시

### 1. 기본 레코드 저장
```bash
fs put customer-profile \
  --record '{"customer_id": "cust_12345", "event_time": "2024-01-15T10:30:00Z", "age": "35", "balance": "1250.75", "category": "premium"}'
```

### 2. 여러 줄로 구성된 JSON 레코드
```bash
fs put customer-profile --record '{
  "customer_id": "cust_67890",
  "event_time": "2024-01-15T11:00:00Z",
  "age": "28",
  "balance": "850.50",
  "category": "standard",
  "location": "Seoul",
  "last_login": "2024-01-15T10:45:00Z"
}'
```

### 3. 환경 변수를 사용한 레코드 생성
```bash
CUSTOMER_ID="cust_11111"
BALANCE="2500.00"
TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

fs put customer-profile --record "{
  \"customer_id\": \"$CUSTOMER_ID\",
  \"event_time\": \"$TIMESTAMP\",
  \"age\": \"42\",
  \"balance\": \"$BALANCE\",
  \"category\": \"vip\"
}"
```

### 4. 파일에서 JSON 읽기
```bash
# record.json 파일 내용
# {
#   "customer_id": "cust_22222",
#   "event_time": "2024-01-15T12:00:00Z",
#   "age": "31",
#   "balance": "1800.25"
# }

fs put customer-profile --record "$(cat record.json)"
```

## 고급 사용 시나리오

### 1. 배치 스크립트에서 여러 레코드 저장
```bash
#!/bin/bash
FEATURE_GROUP="user-activity"
TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

# 여러 사용자 활동 기록
USER_IDS=("user_001" "user_002" "user_003")
ACTIVITIES=("login" "purchase" "logout")

for user_id in "${USER_IDS[@]}"; do
  for activity in "${ACTIVITIES[@]}"; do
    echo "Recording $activity for $user_id"
    fs put $FEATURE_GROUP --record "{
      \"user_id\": \"$user_id\",
      \"event_time\": \"$TIMESTAMP\",
      \"activity_type\": \"$activity\",
      \"session_duration\": \"$(($RANDOM % 3600))\",
      \"page_views\": \"$(($RANDOM % 50))\"
    }"
    sleep 1  # API 호출 간격 조절
  done
done
```

### 2. 실시간 데이터 스트리밍
```bash
#!/bin/bash
FEATURE_GROUP="sensor-data"

while true; do
  # 센서 데이터 시뮬레이션
  SENSOR_ID="sensor_$(($RANDOM % 100))"
  TEMPERATURE=$(echo "scale=2; $RANDOM/32767*40+10" | bc)  # 10-50도
  HUMIDITY=$(echo "scale=2; $RANDOM/32767*100" | bc)        # 0-100%
  TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  
  fs put $FEATURE_GROUP --record "{
    \"sensor_id\": \"$SENSOR_ID\",
    \"event_time\": \"$TIMESTAMP\",
    \"temperature\": \"$TEMPERATURE\",
    \"humidity\": \"$HUMIDITY\",
    \"status\": \"active\"
  }"
  
  sleep 5  # 5초마다 데이터 전송
done
```

### 3. CSV 데이터를 JSON으로 변환하여 저장
```bash
#!/bin/bash
CSV_FILE="customers.csv"
FEATURE_GROUP="customer-profile"

# CSV 헤더: customer_id,age,balance,category
while IFS=',' read -r customer_id age balance category; do
  # 헤더 라인 스킵
  if [ "$customer_id" = "customer_id" ]; then
    continue
  fi
  
  TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  
  echo "Importing customer: $customer_id"
  fs put $FEATURE_GROUP --record "{
    \"customer_id\": \"$customer_id\",
    \"event_time\": \"$TIMESTAMP\",
    \"age\": \"$age\",
    \"balance\": \"$balance\",
    \"category\": \"$category\"
  }"
done < "$CSV_FILE"
```

### 4. 조건부 업데이트 (기존 레코드 확인 후 저장)
```bash
#!/bin/bash
update_if_changed() {
  local feature_group=$1
  local customer_id=$2
  local new_balance=$3
  
  # 기존 레코드 조회
  current_record=$(fs get $feature_group $customer_id 2>/dev/null)
  
  if [ $? -eq 0 ]; then
    # 기존 레코드가 있는 경우
    current_balance=$(echo "$current_record" | jq -r '.balance')
    
    if [ "$current_balance" != "$new_balance" ]; then
      echo "Updating balance for $customer_id: $current_balance -> $new_balance"
      
      # 기존 레코드에 새 잔액 적용
      updated_record=$(echo "$current_record" | jq --arg balance "$new_balance" '.balance = $balance')
      updated_record=$(echo "$updated_record" | jq --arg time "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" '.event_time = $time')
      
      fs put $feature_group --record "$updated_record"
    else
      echo "No change needed for $customer_id"
    fi
  else
    # 새 레코드 생성
    echo "Creating new record for $customer_id"
    fs put $feature_group --record "{
      \"customer_id\": \"$customer_id\",
      \"event_time\": \"$(date -u +"%Y-%m-%dT%H:%M:%SZ")\",
      \"balance\": \"$new_balance\"
    }"
  fi
}

update_if_changed "customer-profile" "cust_12345" "1500.00"
```

### 5. 데이터 검증 후 저장
```bash
#!/bin/bash
validate_and_put() {
  local feature_group=$1
  local record_json=$2
  
  # JSON 유효성 검사
  if ! echo "$record_json" | jq empty 2>/dev/null; then
    echo "Error: Invalid JSON format"
    return 1
  fi
  
  # 필수 필드 확인
  customer_id=$(echo "$record_json" | jq -r '.customer_id')
  age=$(echo "$record_json" | jq -r '.age')
  
  if [ "$customer_id" = "null" ] || [ -z "$customer_id" ]; then
    echo "Error: customer_id is required"
    return 1
  fi
  
  if [ "$age" = "null" ] || [ -z "$age" ]; then
    echo "Error: age is required"
    return 1
  fi
  
  # 데이터 타입 검증
  if ! [[ "$age" =~ ^[0-9]+$ ]] || [ "$age" -lt 0 ] || [ "$age" -gt 120 ]; then
    echo "Error: Invalid age value: $age"
    return 1
  fi
  
  # 검증 통과 시 저장
  echo "Validation passed, storing record..."
  fs put $feature_group --record "$record_json"
}

# 사용 예시
RECORD='{
  "customer_id": "cust_33333",
  "event_time": "2024-01-15T13:00:00Z",
  "age": "29",
  "balance": "999.99"
}'

validate_and_put "customer-profile" "$RECORD"
```

### 6. 임베딩 벡터 데이터 저장
```bash
#!/bin/bash
store_embedding() {
  local feature_group=$1
  local item_id=$2
  local embedding_vector=$3  # 쉼표로 구분된 벡터 값
  
  # 벡터를 JSON 배열로 변환
  embedding_json=$(echo "$embedding_vector" | sed 's/,/", "/g' | sed 's/^/"/' | sed 's/$/"/')
  
  TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  
  fs put $feature_group --record "{
    \"item_id\": \"$item_id\",
    \"event_time\": \"$TIMESTAMP\",
    \"embedding\": [$embedding_json],
    \"model_version\": \"v2.1\",
    \"dimensions\": \"$(echo $embedding_vector | tr ',' '\n' | wc -l)\"
  }"
}

# 128차원 임베딩 벡터 예시
EMBEDDING="0.1,0.2,0.3,0.4,0.5,0.1,0.2,0.3,0.4,0.5,0.1,0.2,0.3,0.4,0.5"
store_embedding "item-embeddings" "item_12345" "$EMBEDDING"
```

### 7. 세션 기반 데이터 저장
```bash
#!/bin/bash
SESSION_ID="session_$(date +%s)"
USER_ID="user_12345"
FEATURE_GROUP="user-sessions"

# 세션 시작
start_session() {
  echo "Starting session: $SESSION_ID"
  fs put $FEATURE_GROUP --record "{
    \"session_id\": \"$SESSION_ID\",
    \"user_id\": \"$USER_ID\",
    \"event_time\": \"$(date -u +"%Y-%m-%dT%H:%M:%SZ")\",
    \"session_start\": \"$(date -u +"%Y-%m-%dT%H:%M:%SZ")\",
    \"status\": \"active\",
    \"page_views\": \"1\"
  }"
}

# 세션 활동 업데이트
update_session() {
  local page_views=$1
  
  fs put $FEATURE_GROUP --record "{
    \"session_id\": \"$SESSION_ID\",
    \"user_id\": \"$USER_ID\",
    \"event_time\": \"$(date -u +"%Y-%m-%dT%H:%M:%SZ")\",
    \"status\": \"active\",
    \"page_views\": \"$page_views\",
    \"last_activity\": \"$(date -u +"%Y-%m-%dT%H:%M:%SZ")\"
  }"
}

# 세션 종료
end_session() {
  local final_page_views=$1
  
  fs put $FEATURE_GROUP --record "{
    \"session_id\": \"$SESSION_ID\",
    \"user_id\": \"$USER_ID\",
    \"event_time\": \"$(date -u +"%Y-%m-%dT%H:%M:%SZ")\",
    \"status\": \"ended\",
    \"page_views\": \"$final_page_views\",
    \"session_end\": \"$(date -u +"%Y-%m-%dT%H:%M:%SZ")\"
  }"
}

# 사용 예시
start_session
sleep 10
update_session "3"
sleep 20
update_session "7"
sleep 15
end_session "10"
```

## 데이터 타입별 저장 가이드

### 1. 문자열 데이터
```bash
fs put text-features --record '{
  "text_id": "text_001",
  "event_time": "2024-01-15T14:00:00Z",
  "title": "Sample Article",
  "content": "This is a long text content...",
  "language": "ko",
  "category": "news"
}'
```

### 2. 숫자 데이터 (정수 및 실수)
```bash
fs put numeric-features --record '{
  "record_id": "num_001",
  "event_time": "2024-01-15T14:00:00Z",
  "integer_field": "42",
  "float_field": "3.14159",
  "price": "1299.99",
  "quantity": "5"
}'
```

### 3. 불린 데이터 (문자열로 저장)
```bash
fs put boolean-features --record '{
  "user_id": "user_001",
  "event_time": "2024-01-15T14:00:00Z",
  "is_premium": "true",
  "email_verified": "false",
  "newsletter_subscribed": "true"
}'
```

### 4. 리스트/배열 데이터
```bash
fs put list-features --record '{
  "item_id": "item_001",
  "event_time": "2024-01-15T14:00:00Z",
  "categories": "[\"electronics\", \"mobile\", \"smartphone\"]",
  "tags": "[\"popular\", \"discount\", \"new\"]",
  "ratings": "[4.5, 4.2, 4.8, 4.1]"
}'
```

## 성능 최적화

### 1. 배치 크기 고려
```bash
#!/bin/bash
# 대용량 데이터 처리 시 적절한 간격 두기
BATCH_SIZE=100
COUNTER=0

while read -r line; do
  fs put feature-group --record "$line"
  
  COUNTER=$((COUNTER + 1))
  if [ $((COUNTER % BATCH_SIZE)) -eq 0 ]; then
    echo "Processed $COUNTER records, sleeping..."
    sleep 1  # API 호출 제한 방지
  fi
done < data.json
```

### 2. 병렬 처리 (신중하게 사용)
```bash
#!/bin/bash
process_record() {
  local record=$1
  fs put feature-group --record "$record"
}

# 최대 5개 프로세스로 병렬 처리
export -f process_record
cat records.json | xargs -n1 -P5 -I{} bash -c 'process_record "{}"'
```

### 3. 오류 처리 및 재시도
```bash
#!/bin/bash
put_with_retry() {
  local feature_group=$1
  local record=$2
  local max_retries=3
  local retry_count=0
  
  while [ $retry_count -lt $max_retries ]; do
    if fs put $feature_group --record "$record"; then
      echo "Successfully stored record"
      return 0
    else
      retry_count=$((retry_count + 1))
      echo "Retry $retry_count/$max_retries failed, waiting..."
      sleep $((retry_count * 2))  # 지수적 백오프
    fi
  done
  
  echo "Failed to store record after $max_retries retries"
  return 1
}

RECORD='{"customer_id": "cust_12345", "event_time": "2024-01-15T14:00:00Z"}'
put_with_retry "customer-profile" "$RECORD"
```

## 오류 처리 및 문제 해결

### 1. JSON 형식 오류
```bash
# 잘못된 JSON 예시
fs put customer-profile --record '{"customer_id": "test" "age": 25}'  # 쉼표 누락

# 올바른 JSON 예시  
fs put customer-profile --record '{"customer_id": "test", "age": "25"}'

# JSON 유효성 사전 검사
RECORD='{"customer_id": "test", "age": "25"}'
if echo "$RECORD" | jq empty 2>/dev/null; then
  fs put customer-profile --record "$RECORD"
else
  echo "Invalid JSON format"
fi
```

### 2. 필수 필드 누락
```bash
# 오류 예시: Record Identifier 필드 누락
fs put customer-profile --record '{"age": "25", "balance": "100"}'
# 해결: customer_id 필드 추가 필요

fs put customer-profile --record '{"customer_id": "cust_123", "age": "25", "balance": "100"}'
```

### 3. 데이터 타입 오류
```bash
# SageMaker FeatureStore는 모든 값을 문자열로 저장
# 숫자도 문자열로 전달해야 함

# 잘못된 예시
fs put customer-profile --record '{"customer_id": "test", "age": 25}'

# 올바른 예시
fs put customer-profile --record '{"customer_id": "test", "age": "25"}'
```

### 4. EventTime 형식 오류
```bash
# 잘못된 시간 형식
fs put customer-profile --record '{"customer_id": "test", "event_time": "2024-01-15"}'

# 올바른 ISO 8601 형식
fs put customer-profile --record '{"customer_id": "test", "event_time": "2024-01-15T14:00:00Z"}'

# 현재 시간 자동 생성
TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
fs put customer-profile --record "{\"customer_id\": \"test\", \"event_time\": \"$TIMESTAMP\"}"
```

## 모니터링 및 로깅

### 1. 저장 성공/실패 로깅
```bash
#!/bin/bash
LOG_FILE="/var/log/feature_store_puts.log"

log_put_operation() {
  local feature_group=$1
  local record=$2
  local status=$3
  local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
  
  echo "[$timestamp] PUT $feature_group: $status" >> $LOG_FILE
  if [ "$status" = "FAILED" ]; then
    echo "[$timestamp] Record: $record" >> $LOG_FILE
  fi
}

# 사용 예시
RECORD='{"customer_id": "cust_123", "event_time": "2024-01-15T14:00:00Z"}'
if fs put customer-profile --record "$RECORD"; then
  log_put_operation "customer-profile" "$RECORD" "SUCCESS"
else
  log_put_operation "customer-profile" "$RECORD" "FAILED"
fi
```

### 2. 처리량 모니터링
```bash
#!/bin/bash
monitor_throughput() {
  local start_time=$(date +%s)
  local record_count=0
  
  while read -r record; do
    fs put feature-group --record "$record"
    record_count=$((record_count + 1))
    
    if [ $((record_count % 100)) -eq 0 ]; then
      current_time=$(date +%s)
      elapsed=$((current_time - start_time))
      throughput=$((record_count / elapsed))
      echo "Processed $record_count records in ${elapsed}s (${throughput} records/sec)"
    fi
  done < records.json
}

monitor_throughput
```

## 모범 사례

1. **EventTime 필드**: 항상 ISO 8601 형식으로 제공
2. **데이터 타입**: 모든 값을 문자열로 변환하여 저장
3. **JSON 검증**: 저장 전 JSON 형식 유효성 검사
4. **오류 처리**: 재시도 로직 및 적절한 에러 핸들링
5. **API 제한**: 과도한 호출 시 적절한 간격 두기
6. **로깅**: 저장 작업의 성공/실패 기록
7. **데이터 검증**: 필수 필드 및 데이터 범위 확인

## 관련 명령어
- `fs bulk-put`: 대량 레코드 저장
- `fs get`: 저장된 레코드 조회
- `fs create`: Feature Group 생성
- `fs schema`: 스키마 구조 확인