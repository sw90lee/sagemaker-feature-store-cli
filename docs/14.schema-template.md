# 14. schema-template 명령어

새로운 feature definition을 위한 템플릿 파일을 생성하는 명령어입니다.

## 기본 사용법

```bash
# 기본 템플릿 생성
fs schema-template

# 특정 파일명으로 템플릿 생성
fs schema-template --output my_features.json
```

## 명령어 옵션

| 옵션 | 설명 | 기본값 |
|------|------|--------|
| `--output`, `-o` | 출력 파일 경로 | feature_template.json |

## 생성되는 템플릿 구조

기본 템플릿에는 다양한 Feature Type과 Collection Type의 예시가 포함됩니다:

```json
[
  {
    "FeatureName": "example_string_feature",
    "FeatureType": "String",
    "Description": "예시 문자열 feature"
  },
  {
    "FeatureName": "example_integral_feature",
    "FeatureType": "Integral", 
    "Description": "예시 정수형 feature"
  },
  {
    "FeatureName": "example_fractional_feature",
    "FeatureType": "Fractional",
    "Description": "예시 실수형 feature"
  },
  {
    "FeatureName": "example_list_feature",
    "FeatureType": "String",
    "CollectionType": "List",
    "CollectionConfig": {
      "VectorConfig": {
        "Dimension": 128
      }
    },
    "Description": "예시 벡터 리스트 feature"
  }
]
```

## Feature Type 참고

### 기본 데이터 타입

| Type | 설명 | 예시 값 |
|------|------|---------|
| `String` | 문자열 데이터 | "premium", "active", "2024-01-01" |
| `Integral` | 정수형 데이터 | 25, 100, -5 |
| `Fractional` | 실수형 데이터 | 3.14, 99.99, -0.5 |

### Collection Type

| Type | 설명 | 필수 설정 | 예시 |
|------|------|----------|------|
| `List` | 벡터/배열 형태 | VectorConfig.Dimension | [0.1, 0.2, 0.3] |
| `Set` | 집합 형태 | - | {"red", "blue", "green"} |

## 상세 사용 예시

### 기본 템플릿 생성 및 사용

```bash
# 1. 기본 템플릿 생성
fs schema-template

# 출력:
# ✅ Feature definition 템플릿이 생성되었습니다: feature_template.json
# 
# 📝 템플릿 사용법:
#   1. 템플릿 파일을 편집하여 원하는 feature들을 정의하세요
#   2. 'fs add-features <feature-group-name> <template-file>' 명령으로 추가하세요
# 
# 📖 FeatureType 옵션:
#   - String: 문자열 데이터
#   - Integral: 정수형 데이터
#   - Fractional: 실수형 데이터
# 
# 📖 CollectionType 옵션:
#   - List: 벡터나 배열 형태의 데이터
#   - Set: 집합 형태의 데이터

# 2. 생성된 템플릿 확인
cat feature_template.json

# 3. 템플릿 편집
vim feature_template.json

# 4. Feature 추가에 사용
fs add-features my-feature-group feature_template.json --dry-run
fs add-features my-feature-group feature_template.json
```

### 특정 용도별 템플릿 생성

```bash
# 고객 데이터용 템플릿
fs schema-template --output customer_features.json

# ML 모델용 템플릿
fs schema-template --output ml_features.json

# 분석용 템플릿
fs schema-template --output analytics_features.json
```

## 고급 사용 시나리오

### 1. 도메인별 스마트 템플릿 생성기

```bash
#!/bin/bash
# smart_template_generator.sh - 도메인별 스마트 템플릿 생성

generate_domain_template() {
    local domain="$1"
    local output_file="${2:-${domain}_features.json}"
    
    case "$domain" in
        "ecommerce")
            generate_ecommerce_template "$output_file"
            ;;
        "finance")
            generate_finance_template "$output_file"
            ;;
        "ml")
            generate_ml_template "$output_file"
            ;;
        "iot")
            generate_iot_template "$output_file"
            ;;
        "social")
            generate_social_template "$output_file"
            ;;
        *)
            echo "❌ 지원하지 않는 도메인: $domain"
            echo "지원 도메인: ecommerce, finance, ml, iot, social"
            return 1
            ;;
    esac
}

generate_ecommerce_template() {
    local output_file="$1"
    
    echo "🛒 E-commerce Feature 템플릿 생성: $output_file"
    
    cat > "$output_file" << 'EOF'
[
  {
    "FeatureName": "customer_id",
    "FeatureType": "String",
    "Description": "고유한 고객 식별자"
  },
  {
    "FeatureName": "customer_segment",
    "FeatureType": "String", 
    "Description": "고객 세그먼트 (VIP, Premium, Standard, Basic)"
  },
  {
    "FeatureName": "lifetime_value",
    "FeatureType": "Fractional",
    "Description": "고객 생애 가치 (CLV)"
  },
  {
    "FeatureName": "purchase_count_30d",
    "FeatureType": "Integral",
    "Description": "최근 30일간 구매 횟수"
  },
  {
    "FeatureName": "total_spent_amount",
    "FeatureType": "Fractional",
    "Description": "총 구매 금액"
  },
  {
    "FeatureName": "preferred_categories",
    "FeatureType": "String",
    "CollectionType": "Set",
    "Description": "선호하는 상품 카테고리 집합"
  },
  {
    "FeatureName": "browsing_history_embeddings",
    "FeatureType": "String",
    "CollectionType": "List",
    "CollectionConfig": {
      "VectorConfig": {
        "Dimension": 256
      }
    },
    "Description": "브라우징 이력 기반 임베딩 벡터"
  },
  {
    "FeatureName": "churn_probability",
    "FeatureType": "Fractional",
    "Description": "이탈 확률 점수 (0.0-1.0)"
  },
  {
    "FeatureName": "last_purchase_date",
    "FeatureType": "String",
    "Description": "마지막 구매일 (YYYY-MM-DD 형식)"
  },
  {
    "FeatureName": "avg_order_value",
    "FeatureType": "Fractional",
    "Description": "평균 주문 금액"
  },
  {
    "FeatureName": "product_ratings",
    "FeatureType": "String",
    "CollectionType": "List",
    "CollectionConfig": {
      "VectorConfig": {
        "Dimension": 50
      }
    },
    "Description": "상품별 평점 이력 벡터"
  },
  {
    "FeatureName": "event_time",
    "FeatureType": "Fractional",
    "Description": "이벤트 발생 시간 (Unix timestamp)"
  }
]
EOF
    
    echo "✅ E-commerce 템플릿 생성 완료"
    echo "💡 주요 특징:"
    echo "  - 고객 세분화 features"
    echo "  - 구매 행동 분석 features" 
    echo "  - 개인화 추천을 위한 임베딩"
    echo "  - 이탈 예측 features"
}

generate_finance_template() {
    local output_file="$1"
    
    echo "💰 Finance Feature 템플릿 생성: $output_file"
    
    cat > "$output_file" << 'EOF'
[
  {
    "FeatureName": "account_id",
    "FeatureType": "String",
    "Description": "계좌 고유 식별자"
  },
  {
    "FeatureName": "account_balance",
    "FeatureType": "Fractional",
    "Description": "현재 계좌 잔액"
  },
  {
    "FeatureName": "credit_score",
    "FeatureType": "Integral",
    "Description": "신용 점수 (300-850)"
  },
  {
    "FeatureName": "monthly_income",
    "FeatureType": "Fractional",
    "Description": "월 소득"
  },
  {
    "FeatureName": "debt_to_income_ratio",
    "FeatureType": "Fractional",
    "Description": "소득 대비 부채 비율"
  },
  {
    "FeatureName": "transaction_count_30d",
    "FeatureType": "Integral",
    "Description": "최근 30일간 거래 횟수"
  },
  {
    "FeatureName": "avg_transaction_amount",
    "FeatureType": "Fractional",
    "Description": "평균 거래 금액"
  },
  {
    "FeatureName": "transaction_categories",
    "FeatureType": "String",
    "CollectionType": "Set",
    "Description": "거래 카테고리 집합"
  },
  {
    "FeatureName": "risk_indicators",
    "FeatureType": "String",
    "CollectionType": "List",
    "CollectionConfig": {
      "VectorConfig": {
        "Dimension": 20
      }
    },
    "Description": "리스크 지표 벡터"
  },
  {
    "FeatureName": "fraud_score",
    "FeatureType": "Fractional",
    "Description": "사기 위험 점수 (0.0-1.0)"
  },
  {
    "FeatureName": "account_age_days",
    "FeatureType": "Integral",
    "Description": "계좌 개설 후 경과 일수"
  },
  {
    "FeatureName": "default_probability",
    "FeatureType": "Fractional",
    "Description": "채무불이행 확률"
  },
  {
    "FeatureName": "event_time",
    "FeatureType": "Fractional",
    "Description": "이벤트 발생 시간 (Unix timestamp)"
  }
]
EOF
    
    echo "✅ Finance 템플릿 생성 완료"
    echo "💡 주요 특징:"
    echo "  - 신용 평가 features"
    echo "  - 리스크 관리 features"
    echo "  - 사기 탐지 features"
    echo "  - 규제 준수 features"
}

generate_ml_template() {
    local output_file="$1"
    
    echo "🤖 ML Feature 템플릿 생성: $output_file"
    
    cat > "$output_file" << 'EOF'
[
  {
    "FeatureName": "entity_id",
    "FeatureType": "String",
    "Description": "엔터티 고유 식별자"
  },
  {
    "FeatureName": "numerical_feature_1",
    "FeatureType": "Fractional",
    "Description": "정규화된 수치형 feature"
  },
  {
    "FeatureName": "numerical_feature_2",
    "FeatureType": "Fractional",
    "Description": "표준화된 수치형 feature"
  },
  {
    "FeatureName": "categorical_encoded",
    "FeatureType": "Integral",
    "Description": "원핫 인코딩된 카테고리 feature"
  },
  {
    "FeatureName": "text_embeddings",
    "FeatureType": "String",
    "CollectionType": "List",
    "CollectionConfig": {
      "VectorConfig": {
        "Dimension": 768
      }
    },
    "Description": "BERT 기반 텍스트 임베딩"
  },
  {
    "FeatureName": "image_features",
    "FeatureType": "String",
    "CollectionType": "List",
    "CollectionConfig": {
      "VectorConfig": {
        "Dimension": 2048
      }
    },
    "Description": "CNN 추출 이미지 특성"
  },
  {
    "FeatureName": "sequence_features",
    "FeatureType": "String",
    "CollectionType": "List",
    "CollectionConfig": {
      "VectorConfig": {
        "Dimension": 100
      }
    },
    "Description": "시퀀스 데이터 특성"
  },
  {
    "FeatureName": "interaction_features",
    "FeatureType": "String",
    "CollectionType": "List",
    "CollectionConfig": {
      "VectorConfig": {
        "Dimension": 50
      }
    },
    "Description": "교차 특성 벡터"
  },
  {
    "FeatureName": "target_variable",
    "FeatureType": "Fractional",
    "Description": "예측 대상 변수"
  },
  {
    "FeatureName": "prediction_confidence",
    "FeatureType": "Fractional",
    "Description": "예측 신뢰도 점수"
  },
  {
    "FeatureName": "model_version",
    "FeatureType": "String",
    "Description": "사용된 모델 버전"
  },
  {
    "FeatureName": "feature_importance",
    "FeatureType": "String",
    "CollectionType": "List",
    "CollectionConfig": {
      "VectorConfig": {
        "Dimension": 10
      }
    },
    "Description": "Feature 중요도 가중치"
  },
  {
    "FeatureName": "event_time",
    "FeatureType": "Fractional",
    "Description": "이벤트 발생 시간 (Unix timestamp)"
  }
]
EOF
    
    echo "✅ ML 템플릿 생성 완료"
    echo "💡 주요 특징:"
    echo "  - 고차원 임베딩 벡터"
    echo "  - 모델 예측 관련 features"
    echo "  - Feature 중요도 추적"
    echo "  - 다양한 데이터 타입 지원"
}

generate_iot_template() {
    local output_file="$1"
    
    echo "📡 IoT Feature 템플릿 생성: $output_file"
    
    cat > "$output_file" << 'EOF'
[
  {
    "FeatureName": "device_id",
    "FeatureType": "String",
    "Description": "IoT 디바이스 고유 식별자"
  },
  {
    "FeatureName": "sensor_temperature",
    "FeatureType": "Fractional",
    "Description": "온도 센서 값 (섭씨)"
  },
  {
    "FeatureName": "sensor_humidity",
    "FeatureType": "Fractional",
    "Description": "습도 센서 값 (%)"
  },
  {
    "FeatureName": "sensor_pressure",
    "FeatureType": "Fractional",
    "Description": "기압 센서 값 (hPa)"
  },
  {
    "FeatureName": "battery_level",
    "FeatureType": "Fractional",
    "Description": "배터리 잔량 (%)"
  },
  {
    "FeatureName": "signal_strength",
    "FeatureType": "Integral",
    "Description": "신호 강도 (dBm)"
  },
  {
    "FeatureName": "location_coordinates",
    "FeatureType": "String",
    "CollectionType": "List",
    "CollectionConfig": {
      "VectorConfig": {
        "Dimension": 2
      }
    },
    "Description": "GPS 좌표 [위도, 경도]"
  },
  {
    "FeatureName": "accelerometer_data",
    "FeatureType": "String",
    "CollectionType": "List",
    "CollectionConfig": {
      "VectorConfig": {
        "Dimension": 3
      }
    },
    "Description": "가속도계 데이터 [x, y, z]"
  },
  {
    "FeatureName": "device_status",
    "FeatureType": "String",
    "Description": "디바이스 상태 (online, offline, maintenance)"
  },
  {
    "FeatureName": "error_codes",
    "FeatureType": "String",
    "CollectionType": "Set",
    "Description": "에러 코드 집합"
  },
  {
    "FeatureName": "uptime_hours",
    "FeatureType": "Fractional",
    "Description": "연속 가동 시간 (시간)"
  },
  {
    "FeatureName": "data_transmission_rate",
    "FeatureType": "Fractional",
    "Description": "데이터 전송률 (MB/s)"
  },
  {
    "FeatureName": "anomaly_score",
    "FeatureType": "Fractional",
    "Description": "이상 탐지 점수"
  },
  {
    "FeatureName": "event_time",
    "FeatureType": "Fractional",
    "Description": "이벤트 발생 시간 (Unix timestamp)"
  }
]
EOF
    
    echo "✅ IoT 템플릿 생성 완료"
    echo "💡 주요 특징:"
    echo "  - 센서 데이터 features"
    echo "  - 디바이스 상태 추적"
    echo "  - 위치 및 움직임 데이터"
    echo "  - 이상 탐지 features"
}

generate_social_template() {
    local output_file="$1"
    
    echo "👥 Social Media Feature 템플릿 생성: $output_file"
    
    cat > "$output_file" << 'EOF'
[
  {
    "FeatureName": "user_id",
    "FeatureType": "String",
    "Description": "사용자 고유 식별자"
  },
  {
    "FeatureName": "follower_count",
    "FeatureType": "Integral",
    "Description": "팔로워 수"
  },
  {
    "FeatureName": "following_count", 
    "FeatureType": "Integral",
    "Description": "팔로잉 수"
  },
  {
    "FeatureName": "post_count",
    "FeatureType": "Integral",
    "Description": "총 게시물 수"
  },
  {
    "FeatureName": "engagement_rate",
    "FeatureType": "Fractional",
    "Description": "참여율 (좋아요+댓글+공유)/팔로워"
  },
  {
    "FeatureName": "avg_likes_per_post",
    "FeatureType": "Fractional",
    "Description": "게시물당 평균 좋아요 수"
  },
  {
    "FeatureName": "content_categories",
    "FeatureType": "String",
    "CollectionType": "Set",
    "Description": "주요 콘텐츠 카테고리"
  },
  {
    "FeatureName": "post_embeddings",
    "FeatureType": "String",
    "CollectionType": "List",
    "CollectionConfig": {
      "VectorConfig": {
        "Dimension": 512
      }
    },
    "Description": "게시물 내용 임베딩"
  },
  {
    "FeatureName": "sentiment_scores",
    "FeatureType": "String",
    "CollectionType": "List",
    "CollectionConfig": {
      "VectorConfig": {
        "Dimension": 3
      }
    },
    "Description": "감정 분석 점수 [긍정, 중립, 부정]"
  },
  {
    "FeatureName": "influence_score",
    "FeatureType": "Fractional",
    "Description": "영향력 점수"
  },
  {
    "FeatureName": "activity_level",
    "FeatureType": "String",
    "Description": "활동 수준 (high, medium, low)"
  },
  {
    "FeatureName": "account_verified",
    "FeatureType": "String",
    "Description": "계정 인증 여부 (verified, unverified)"
  },
  {
    "FeatureName": "account_age_days",
    "FeatureType": "Integral",
    "Description": "계정 생성 후 경과 일수"
  },
  {
    "FeatureName": "event_time",
    "FeatureType": "Fractional",
    "Description": "이벤트 발생 시간 (Unix timestamp)"
  }
]
EOF
    
    echo "✅ Social Media 템플릿 생성 완료"
    echo "💡 주요 특징:"
    echo "  - 사용자 참여도 metrics"
    echo "  - 콘텐츠 분석 features"
    echo "  - 영향력 측정 features"
    echo "  - 감정 분석 기능"
}

# 사용 예시
echo "🎯 도메인별 스마트 템플릿 생성기"
echo ""
echo "사용법: generate_domain_template <domain> [output_file]"
echo ""
echo "지원 도메인:"
echo "  - ecommerce: 전자상거래 features"
echo "  - finance: 금융 서비스 features" 
echo "  - ml: 머신러닝 모델 features"
echo "  - iot: IoT 디바이스 features"
echo "  - social: 소셜미디어 features"
echo ""
echo "예시:"
echo "  generate_domain_template ecommerce"
echo "  generate_domain_template finance finance_template.json"
echo "  generate_domain_template ml ml_features.json"

# 함수 실행 (사용자가 호출)
if [ $# -gt 0 ]; then
    generate_domain_template "$@"
fi
```

### 2. 대화형 템플릿 빌더

```bash
#!/bin/bash
# interactive_template_builder.sh - 대화형 템플릿 생성기

build_interactive_template() {
    local output_file="${1:-custom_features.json}"
    
    echo "🎯 대화형 Feature 템플릿 빌더"
    echo "출력 파일: $output_file"
    echo ""
    
    # 기본 정보 수집
    echo "📋 기본 정보 입력"
    echo "─────────────────"
    
    read -p "Feature Group 이름 (예: customer-data): " feature_group_name
    read -p "프로젝트 설명 (예: 고객 분석용 features): " project_description
    
    echo ""
    echo "🔧 Feature 정의"
    echo "─────────────"
    
    features=()
    feature_count=0
    
    while true; do
        echo ""
        echo "Feature #$((feature_count + 1)) 정의:"
        
        # Feature 이름
        read -p "  Feature 이름 (빈 값 입력시 종료): " feature_name
        if [ -z "$feature_name" ]; then
            break
        fi
        
        # Feature 타입 선택
        echo "  Feature 타입 선택:"
        echo "    1) String (문자열)"
        echo "    2) Integral (정수)"
        echo "    3) Fractional (실수)"
        
        while true; do
            read -p "  선택 (1-3): " type_choice
            case "$type_choice" in
                1) feature_type="String"; break ;;
                2) feature_type="Integral"; break ;;
                3) feature_type="Fractional"; break ;;
                *) echo "    ⚠️  1, 2, 3 중에서 선택해주세요" ;;
            esac
        done
        
        # Collection 타입 선택
        echo "  Collection 타입이 필요한가요?"
        echo "    1) 아니오 (단일 값)"
        echo "    2) List (벡터/배열)"
        echo "    3) Set (집합)"
        
        collection_type=""
        collection_config=""
        
        while true; do
            read -p "  선택 (1-3): " collection_choice
            case "$collection_choice" in
                1) break ;;
                2) 
                    collection_type="List"
                    read -p "    벡터 차원 (예: 128): " dimension
                    if [ -n "$dimension" ] && [ "$dimension" -gt 0 ] 2>/dev/null; then
                        collection_config="{\"VectorConfig\":{\"Dimension\":$dimension}}"
                    else
                        echo "    ⚠️  잘못된 차원값, 기본값 128 사용"
                        collection_config="{\"VectorConfig\":{\"Dimension\":128}}"
                    fi
                    break 
                    ;;
                3) collection_type="Set"; break ;;
                *) echo "    ⚠️  1, 2, 3 중에서 선택해주세요" ;;
            esac
        done
        
        # 설명
        read -p "  Feature 설명 (선택사항): " feature_description
        
        # Feature 객체 구성
        feature_json="{"
        feature_json+="\"FeatureName\":\"$feature_name\""
        feature_json+=",\"FeatureType\":\"$feature_type\""
        
        if [ -n "$collection_type" ]; then
            feature_json+=",\"CollectionType\":\"$collection_type\""
        fi
        
        if [ -n "$collection_config" ]; then
            feature_json+=",\"CollectionConfig\":$collection_config"
        fi
        
        if [ -n "$feature_description" ]; then
            feature_json+=",\"Description\":\"$feature_description\""
        fi
        
        feature_json+="}"
        
        features+=("$feature_json")
        feature_count=$((feature_count + 1))
        
        echo "  ✅ Feature 추가됨: $feature_name ($feature_type)"
        
        # 계속 여부 확인
        if [ $feature_count -ge 10 ]; then
            echo ""
            echo "⚠️  10개 이상의 feature를 추가했습니다. 계속하시겠습니까? (y/N)"
            read -r continue_adding
            if [[ ! $continue_adding =~ ^[Yy]$ ]]; then
                break
            fi
        fi
    done
    
    if [ ${#features[@]} -eq 0 ]; then
        echo ""
        echo "❌ Feature가 추가되지 않았습니다. 템플릿 생성을 취소합니다."
        return 1
    fi
    
    # event_time feature 자동 추가 확인
    echo ""
    echo "📅 event_time feature를 자동으로 추가하시겠습니까? (Y/n)"
    read -r add_event_time
    
    if [[ ! $add_event_time =~ ^[Nn]$ ]]; then
        event_time_feature='{"FeatureName":"event_time","FeatureType":"Fractional","Description":"이벤트 발생 시간 (Unix timestamp)"}'
        features+=("$event_time_feature")
        feature_count=$((feature_count + 1))
        echo "  ✅ event_time feature 추가됨"
    fi
    
    # JSON 파일 생성
    echo ""
    echo "💾 템플릿 파일 생성 중..."
    
    # JSON 배열 구성
    json_content="["
    for i in "${!features[@]}"; do
        if [ $i -gt 0 ]; then
            json_content+=","
        fi
        json_content+="${features[$i]}"
    done
    json_content+="]"
    
    # 예쁘게 포맷팅하여 파일 저장
    echo "$json_content" | python3 -m json.tool > "$output_file"
    
    # 헤더 주석 추가
    temp_file="/tmp/template_with_header.json"
    
    cat > "$temp_file" << EOF
/*
 * Feature Definition Template
 * Generated: $(date)
 * Feature Group: $feature_group_name
 * Description: $project_description
 * Total Features: $feature_count
 */
EOF
    
    cat "$output_file" >> "$temp_file"
    mv "$temp_file" "$output_file"
    
    # 결과 요약
    echo ""
    echo "✅ 대화형 템플릿 생성 완료!"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "📄 파일: $output_file"
    echo "📊 Feature 수: $feature_count개"
    echo "🎯 Feature Group: $feature_group_name"
    echo ""
    
    # Feature 요약 표시
    echo "📋 생성된 Features:"
    python3 << EOF
import json

try:
    with open('$output_file', 'r') as f:
        content = f.read()
        # 주석 제거
        json_start = content.find('[')
        if json_start != -1:
            json_content = content[json_start:]
            features = json.loads(json_content)
            
            for i, feature in enumerate(features, 1):
                name = feature['FeatureName']
                ftype = feature['FeatureType']
                collection = feature.get('CollectionType', '')
                collection_info = f" [{collection}]" if collection else ""
                
                print(f"  {i:2d}. {name} ({ftype}{collection_info})")

except Exception as e:
    print(f"  ⚠️ 요약 표시 중 오류: {e}")
EOF
    
    echo ""
    echo "🚀 다음 단계:"
    echo "  1. 파일 내용 검토: cat $output_file"
    echo "  2. 필요시 추가 편집: vim $output_file"
    echo "  3. Feature 추가: fs add-features $feature_group_name $output_file --dry-run"
    echo "  4. 실제 적용: fs add-features $feature_group_name $output_file"
    
    # 추가 옵션들
    echo ""
    echo "🔧 추가 옵션:"
    echo "  v) 생성된 파일 보기"
    echo "  e) 파일 편집"
    echo "  t) 테스트 실행 (dry-run)"
    echo "  q) 종료"
    
    while true; do
        read -p "선택 (v/e/t/q): " action_choice
        case "$action_choice" in
            v|V)
                echo ""
                echo "📄 생성된 템플릿 내용:"
                echo "─────────────────────"
                cat "$output_file"
                ;;
            e|E)
                echo "📝 파일 편집기 실행..."
                ${EDITOR:-vim} "$output_file"
                echo "✅ 편집 완료"
                ;;
            t|T)
                if [ -n "$feature_group_name" ]; then
                    echo "🧪 테스트 실행 중..."
                    if fs add-features "$feature_group_name" "$output_file" --dry-run; then
                        echo "✅ 테스트 통과!"
                    else
                        echo "❌ 테스트 실패. 파일을 수정해주세요."
                    fi
                else
                    echo "⚠️  Feature Group 이름이 필요합니다"
                fi
                ;;
            q|Q)
                echo "👋 템플릿 빌더 종료"
                break
                ;;
            *)
                echo "⚠️  v, e, t, q 중에서 선택해주세요"
                ;;
        esac
        echo ""
    done
}

# 사용 예시
echo "🎯 대화형 Feature 템플릿 빌더 시작"
echo ""
echo "사용법: build_interactive_template [output_file]"
echo ""

if [ $# -gt 0 ]; then
    build_interactive_template "$@"
else
    read -p "출력 파일명 (기본값: custom_features.json): " user_output
    build_interactive_template "${user_output:-custom_features.json}"
fi
```

### 3. 기존 데이터에서 템플릿 추론

```bash
#!/bin/bash
# data_driven_template_generator.sh - 데이터 기반 템플릿 생성

infer_template_from_data() {
    local data_file="$1"
    local output_template="${2:-inferred_features.json}"
    local sample_size="${3:-1000}"
    
    if [ ! -f "$data_file" ]; then
        echo "❌ 데이터 파일을 찾을 수 없습니다: $data_file"
        return 1
    fi
    
    echo "🔍 데이터 기반 템플릿 추론"
    echo "입력 파일: $data_file"
    echo "출력 템플릿: $output_template"
    echo "샘플 크기: $sample_size"
    echo ""
    
    # 파일 확장자에 따른 처리
    file_extension="${data_file##*.}"
    
    case "$file_extension" in
        "csv")
            infer_from_csv "$data_file" "$output_template" "$sample_size"
            ;;
        "json")
            infer_from_json "$data_file" "$output_template" "$sample_size"
            ;;
        "parquet")
            infer_from_parquet "$data_file" "$output_template" "$sample_size"
            ;;
        *)
            echo "❌ 지원하지 않는 파일 형식: $file_extension"
            echo "지원 형식: csv, json, parquet"
            return 1
            ;;
    esac
}

infer_from_csv() {
    local csv_file="$1"
    local output_template="$2"
    local sample_size="$3"
    
    echo "📊 CSV 파일 분석 중..."
    
    python3 << EOF
import pandas as pd
import json
import numpy as np
from collections import Counter
import re

# CSV 파일 읽기
try:
    df = pd.read_csv('$csv_file', nrows=$sample_size)
    print(f"✅ 데이터 로드 완료: {len(df)} rows, {len(df.columns)} columns")
except Exception as e:
    print(f"❌ CSV 파일 읽기 실패: {e}")
    exit(1)

print(f"📋 컬럼 목록: {list(df.columns)}")
print("")

features = []

for column in df.columns:
    print(f"🔍 분석 중: {column}")
    
    # 기본 정보
    non_null_count = df[column].notna().sum()
    null_count = len(df) - non_null_count
    
    print(f"  - 유효 값: {non_null_count}, 결측값: {null_count}")
    
    # 데이터 타입 추론
    feature_type = "String"  # 기본값
    collection_type = None
    collection_config = None
    
    if non_null_count == 0:
        print("  ⚠️ 모든 값이 결측값입니다")
        feature_type = "String"
    else:
        # 샘플 값들 분석
        sample_values = df[column].dropna().head(100).tolist()
        
        # 수치형 타입 확인
        numeric_count = 0
        integer_count = 0
        
        for value in sample_values:
            try:
                float_val = float(value)
                numeric_count += 1
                if float_val.is_integer():
                    integer_count += 1
            except:
                pass
        
        numeric_ratio = numeric_count / len(sample_values) if sample_values else 0
        integer_ratio = integer_count / len(sample_values) if sample_values else 0
        
        print(f"  - 수치형 비율: {numeric_ratio:.2%}")
        print(f"  - 정수형 비율: {integer_ratio:.2%}")
        
        # 타입 결정
        if numeric_ratio > 0.8:  # 80% 이상이 수치형
            if integer_ratio > 0.9:  # 90% 이상이 정수
                feature_type = "Integral"
            else:
                feature_type = "Fractional"
        else:
            feature_type = "String"
            
            # 리스트/배열 형태 확인
            list_like_count = 0
            max_list_length = 0
            
            for value in sample_values[:20]:  # 처음 20개만 체크
                str_value = str(value)
                # JSON 배열 형태 체크
                if (str_value.startswith('[') and str_value.endswith(']')) or \
                   (str_value.startswith('{') and str_value.endswith('}')):
                    try:
                        parsed = json.loads(str_value)
                        if isinstance(parsed, list):
                            list_like_count += 1
                            max_list_length = max(max_list_length, len(parsed))
                    except:
                        pass
                # 쉼표로 구분된 값들 체크
                elif ',' in str_value and len(str_value.split(',')) > 1:
                    list_like_count += 1
                    max_list_length = max(max_list_length, len(str_value.split(',')))
            
            list_ratio = list_like_count / min(len(sample_values), 20)
            print(f"  - 리스트형 비율: {list_ratio:.2%}")
            
            if list_ratio > 0.5:  # 50% 이상이 리스트 형태
                collection_type = "List"
                dimension = max(max_list_length, 10)  # 최소 10차원
                collection_config = {
                    "VectorConfig": {"Dimension": dimension}
                }
                print(f"  - 추정 차원: {dimension}")
    
    # 특별한 컬럼명 패턴 처리
    column_lower = column.lower()
    
    # event_time 관련
    if 'time' in column_lower or 'timestamp' in column_lower or 'date' in column_lower:
        if feature_type == "String":
            # 타임스탬프 형식 확인
            timestamp_count = 0
            for value in sample_values[:10]:
                str_value = str(value)
                # Unix timestamp (숫자)
                if str_value.isdigit() and len(str_value) >= 10:
                    timestamp_count += 1
                # ISO format
                elif re.match(r'^\d{4}-\d{2}-\d{2}', str_value):
                    timestamp_count += 1
            
            if timestamp_count > len(sample_values[:10]) * 0.5:
                feature_type = "Fractional"  # Unix timestamp
                print("  💡 타임스탬프로 추정하여 Fractional 타입 적용")
    
    # ID 관련
    if 'id' in column_lower or column_lower.endswith('_id'):
        feature_type = "String"
        print("  💡 ID 필드로 추정하여 String 타입 적용")
    
    # Feature 객체 생성
    feature = {
        "FeatureName": column,
        "FeatureType": feature_type
    }
    
    if collection_type:
        feature["CollectionType"] = collection_type
        if collection_config:
            feature["CollectionConfig"] = collection_config
    
    # 설명 추가
    description_parts = []
    if feature_type == "String":
        unique_count = df[column].nunique()
        description_parts.append(f"고유값 {unique_count}개")
    elif feature_type in ["Integral", "Fractional"]:
        if non_null_count > 0:
            min_val = df[column].min()
            max_val = df[column].max()
            description_parts.append(f"범위: {min_val}~{max_val}")
    
    if null_count > 0:
        null_ratio = null_count / len(df)
        description_parts.append(f"결측률 {null_ratio:.1%}")
    
    if description_parts:
        feature["Description"] = f"데이터 분석 기반 추론 - " + ", ".join(description_parts)
    
    features.append(feature)
    print(f"  ✅ {column} -> {feature_type}" + (f" [{collection_type}]" if collection_type else ""))
    print("")

# 템플릿 저장
with open('$output_template', 'w', encoding='utf-8') as f:
    json.dump(features, f, indent=2, ensure_ascii=False)

print(f"✅ 템플릿 생성 완료: $output_template")
print(f"📊 총 {len(features)}개 features 생성")

# 타입별 통계
type_counter = Counter(f['FeatureType'] for f in features)
print("")
print("📈 Feature Type 분포:")
for ftype, count in type_counter.items():
    print(f"  - {ftype}: {count}개")

collection_counter = Counter(f.get('CollectionType', 'None') for f in features)
if collection_counter.get('List', 0) > 0 or collection_counter.get('Set', 0) > 0:
    print("")
    print("📦 Collection Type 분포:")
    for ctype, count in collection_counter.items():
        if ctype != 'None':
            print(f"  - {ctype}: {count}개")

EOF
    
    echo ""
    echo "✅ CSV 기반 템플릿 추론 완료"
}

infer_from_json() {
    local json_file="$1"
    local output_template="$2" 
    local sample_size="$3"
    
    echo "📄 JSON 파일 분석 중..."
    
    python3 << EOF
import json
from collections import Counter, defaultdict

# JSON 파일 읽기
try:
    with open('$json_file', 'r', encoding='utf-8') as f:
        data = json.load(f)
    
    if isinstance(data, list):
        records = data[:$sample_size] if len(data) > $sample_size else data
        print(f"✅ JSON 배열 로드: {len(records)} records")
    elif isinstance(data, dict):
        records = [data]
        print("✅ JSON 객체 로드: 1 record")
    else:
        print("❌ 지원하지 않는 JSON 구조")
        exit(1)
        
except Exception as e:
    print(f"❌ JSON 파일 읽기 실패: {e}")
    exit(1)

# 모든 필드 수집
all_fields = defaultdict(list)

for record in records:
    if isinstance(record, dict):
        for key, value in record.items():
            all_fields[key].append(value)

print(f"📋 발견된 필드: {len(all_fields)}개")
print("")

features = []

for field_name, values in all_fields.items():
    print(f"🔍 분석 중: {field_name}")
    
    # 널값 제거
    non_null_values = [v for v in values if v is not None]
    null_count = len(values) - len(non_null_values)
    
    print(f"  - 유효 값: {len(non_null_values)}, 널값: {null_count}")
    
    if not non_null_values:
        print("  ⚠️ 모든 값이 널값입니다")
        features.append({
            "FeatureName": field_name,
            "FeatureType": "String",
            "Description": "모든 값이 null인 필드"
        })
        continue
    
    # 타입 분석
    type_counter = Counter(type(v).__name__ for v in non_null_values)
    print(f"  - 타입 분포: {dict(type_counter)}")
    
    # Feature 타입 결정
    feature_type = "String"
    collection_type = None
    collection_config = None
    
    # 가장 많은 타입으로 결정
    most_common_type = type_counter.most_common(1)[0][0]
    
    if most_common_type in ['int', 'float']:
        if most_common_type == 'int' or all(isinstance(v, int) or (isinstance(v, float) and v.is_integer()) 
                                          for v in non_null_values):
            feature_type = "Integral"
        else:
            feature_type = "Fractional"
    elif most_common_type == 'list':
        feature_type = "String"
        collection_type = "List"
        
        # 리스트 차원 분석
        list_lengths = [len(v) for v in non_null_values if isinstance(v, list)]
        if list_lengths:
            avg_length = sum(list_lengths) // len(list_lengths)
            max_length = max(list_lengths)
            dimension = max_length if max_length <= 10000 else avg_length
            collection_config = {"VectorConfig": {"Dimension": dimension}}
            print(f"  - 평균 길이: {avg_length}, 최대 길이: {max_length}")
            print(f"  - 설정 차원: {dimension}")
    else:
        feature_type = "String"
    
    # 특별 필드명 처리
    field_lower = field_name.lower()
    if 'time' in field_lower or 'timestamp' in field_lower:
        if isinstance(non_null_values[0], (int, float)):
            feature_type = "Fractional"
            print("  💡 타임스탬프 필드로 인식")
    
    # Feature 생성
    feature = {
        "FeatureName": field_name,
        "FeatureType": feature_type
    }
    
    if collection_type:
        feature["CollectionType"] = collection_type
        if collection_config:
            feature["CollectionConfig"] = collection_config
    
    # 설명 생성
    description_parts = [f"JSON에서 추론 ({most_common_type} 타입)"]
    if null_count > 0:
        null_ratio = null_count / len(values)
        description_parts.append(f"널값 {null_ratio:.1%}")
    
    feature["Description"] = " - ".join(description_parts)
    features.append(feature)
    
    print(f"  ✅ {field_name} -> {feature_type}" + (f" [{collection_type}]" if collection_type else ""))
    print("")

# 템플릿 저장
with open('$output_template', 'w', encoding='utf-8') as f:
    json.dump(features, f, indent=2, ensure_ascii=False)

print(f"✅ JSON 기반 템플릿 생성 완료: $output_template")
print(f"📊 총 {len(features)}개 features")

EOF
}

# 사용 예시
echo "🔍 데이터 기반 템플릿 추론 시스템"
echo ""
echo "사용법: infer_template_from_data <data_file> [output_template] [sample_size]"
echo ""
echo "지원 형식:"
echo "  - CSV 파일 (.csv)"
echo "  - JSON 파일 (.json)"
echo "  - Parquet 파일 (.parquet)"
echo ""
echo "예시:"
echo "  infer_template_from_data data.csv"
echo "  infer_template_from_data data.json features.json"
echo "  infer_template_from_data big_data.csv inferred.json 5000"

# 실행
if [ $# -gt 0 ]; then
    infer_template_from_data "$@"
fi
```

### 4. 템플릿 검증 및 최적화

```bash
#!/bin/bash
# template_validator.sh - 템플릿 검증 및 최적화

validate_and_optimize_template() {
    local template_file="$1"
    local optimized_file="${2:-optimized_${template_file}}"
    
    if [ ! -f "$template_file" ]; then
        echo "❌ 템플릿 파일을 찾을 수 없습니다: $template_file"
        return 1
    fi
    
    echo "🔍 Feature 템플릿 검증 및 최적화"
    echo "입력 템플릿: $template_file"
    echo "최적화된 출력: $optimized_file"
    echo ""
    
    # Python을 사용한 검증 및 최적화
    python3 << EOF
import json
import re
from collections import Counter

def validate_feature_name(name):
    """Feature 이름 검증"""
    issues = []
    
    # 길이 체크
    if len(name) > 64:
        issues.append(f"이름이 너무 깁니다 ({len(name)}자 > 64자)")
    
    # 패턴 체크
    if not re.match(r'^[a-zA-Z][a-zA-Z0-9_]*$', name):
        issues.append("이름 규칙 위반 (영문자로 시작, 영문/숫자/언더스코어만 허용)")
    
    # 예약어 체크
    reserved = ['time', 'date', 'timestamp', 'record', 'key', 'id', 'name']
    if name.lower() in reserved:
        issues.append(f"예약어 사용: {name}")
    
    # 연속 언더스코어 체크
    if '__' in name:
        issues.append("연속된 언더스코어 사용")
    
    return issues

def validate_feature_type(ftype):
    """Feature 타입 검증"""
    valid_types = ['String', 'Integral', 'Fractional']
    if ftype not in valid_types:
        return [f"잘못된 FeatureType: {ftype}. 유효한 값: {valid_types}"]
    return []

def validate_collection_config(feature):
    """Collection 설정 검증"""
    issues = []
    collection_type = feature.get('CollectionType')
    
    if collection_type == 'List':
        config = feature.get('CollectionConfig', {})
        vector_config = config.get('VectorConfig', {})
        dimension = vector_config.get('Dimension')
        
        if not dimension:
            issues.append("List 타입에는 Dimension이 필요합니다")
        elif not isinstance(dimension, int) or dimension <= 0:
            issues.append(f"Dimension은 양의 정수여야 합니다: {dimension}")
        elif dimension > 10000:
            issues.append(f"Dimension이 너무 큽니다: {dimension} (권장: ≤ 10000)")
    
    elif collection_type and collection_type not in ['List', 'Set']:
        issues.append(f"잘못된 CollectionType: {collection_type}")
    
    return issues

# 템플릿 파일 로드
try:
    with open('$template_file', 'r', encoding='utf-8') as f:
        template = json.load(f)
except Exception as e:
    print(f"❌ 템플릿 파일 읽기 실패: {e}")
    exit(1)

if not isinstance(template, list):
    print("❌ 템플릿은 배열 형태여야 합니다")
    exit(1)

print(f"📊 원본 템플릿: {len(template)}개 features")
print("")

# 검증 결과
validation_results = {
    'errors': [],
    'warnings': [],
    'suggestions': []
}

valid_features = []
feature_names = set()

for i, feature in enumerate(template):
    if not isinstance(feature, dict):
        validation_results['errors'].append(f"Feature #{i+1}: 객체 형태가 아닙니다")
        continue
    
    feature_name = feature.get('FeatureName')
    if not feature_name:
        validation_results['errors'].append(f"Feature #{i+1}: FeatureName이 필요합니다")
        continue
    
    print(f"🔍 검증 중: {feature_name}")
    
    # 중복 이름 체크
    if feature_name in feature_names:
        validation_results['errors'].append(f"중복된 Feature 이름: {feature_name}")
        continue
    feature_names.add(feature_name)
    
    # 개별 검증
    name_issues = validate_feature_name(feature_name)
    type_issues = validate_feature_type(feature.get('FeatureType', ''))
    collection_issues = validate_collection_config(feature)
    
    feature_issues = name_issues + type_issues + collection_issues
    
    if feature_issues:
        for issue in feature_issues:
            validation_results['warnings'].append(f"{feature_name}: {issue}")
    
    # 최적화된 feature 생성
    optimized_feature = feature.copy()
    
    # 이름 최적화
    original_name = feature_name
    optimized_name = feature_name
    
    # 대문자를 소문자+언더스코어로 변경 (camelCase -> snake_case)
    optimized_name = re.sub(r'([A-Z])', r'_\\1', optimized_name).lower().lstrip('_')
    
    # 연속 언더스코어 제거
    optimized_name = re.sub(r'_{2,}', '_', optimized_name)
    
    # 시작/끝 언더스코어 제거
    optimized_name = optimized_name.strip('_')
    
    if optimized_name != original_name:
        validation_results['suggestions'].append(f"이름 최적화: {original_name} -> {optimized_name}")
        optimized_feature['FeatureName'] = optimized_name
    
    # Description 추가/개선
    if not optimized_feature.get('Description'):
        ftype = optimized_feature.get('FeatureType', 'String')
        collection = optimized_feature.get('CollectionType', '')
        
        auto_description = f"{ftype} 타입"
        if collection:
            if collection == 'List':
                dimension = optimized_feature.get('CollectionConfig', {}).get('VectorConfig', {}).get('Dimension', 0)
                auto_description += f", {dimension}차원 벡터"
            else:
                auto_description += f", {collection} 컬렉션"
        
        optimized_feature['Description'] = f"자동 생성 설명: {auto_description}"
        validation_results['suggestions'].append(f"{feature_name}: 설명 자동 추가")
    
    valid_features.append(optimized_feature)
    print(f"  ✅ 검증 완료")

print("")

# 통계 분석
type_counter = Counter(f.get('FeatureType', 'Unknown') for f in valid_features)
collection_counter = Counter(f.get('CollectionType', 'None') for f in valid_features)

print("📈 Feature Type 분포:")
for ftype, count in type_counter.items():
    print(f"  - {ftype}: {count}개")

print("")
print("📦 Collection Type 분포:")
for ctype, count in collection_counter.items():
    print(f"  - {ctype}: {count}개")

# 권장사항
print("")
print("💡 최적화 권장사항:")

if len(valid_features) > 50:
    validation_results['suggestions'].append("Feature 수가 많습니다 (50개 초과). 논리적 그룹핑을 고려하세요")

string_ratio = type_counter.get('String', 0) / len(valid_features) if valid_features else 0
if string_ratio > 0.8:
    validation_results['suggestions'].append(f"String 타입 비율이 높습니다 ({string_ratio:.1%}). 다른 타입 고려해보세요")

vector_count = collection_counter.get('List', 0)
if vector_count > 10:
    validation_results['suggestions'].append(f"벡터 Feature가 많습니다 ({vector_count}개). 성능 영향을 고려하세요")

# 결과 출력
print("")
print("🎯 검증 결과")
print("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")

if validation_results['errors']:
    print(f"❌ 오류 ({len(validation_results['errors'])}개):")
    for error in validation_results['errors']:
        print(f"  - {error}")
    print("")

if validation_results['warnings']:
    print(f"⚠️  경고 ({len(validation_results['warnings'])}개):")
    for warning in validation_results['warnings']:
        print(f"  - {warning}")
    print("")

if validation_results['suggestions']:
    print(f"💡 제안 ({len(validation_results['suggestions'])}개):")
    for suggestion in validation_results['suggestions']:
        print(f"  - {suggestion}")
    print("")

# 최적화된 템플릿 저장
try:
    with open('$optimized_file', 'w', encoding='utf-8') as f:
        json.dump(valid_features, f, indent=2, ensure_ascii=False)
    
    print(f"✅ 최적화된 템플릿 저장: $optimized_file")
    print(f"📊 유효한 Features: {len(valid_features)}개")
    
    # 품질 점수 계산
    total_checks = len(validation_results['errors']) + len(validation_results['warnings'])
    error_penalty = len(validation_results['errors']) * 2
    warning_penalty = len(validation_results['warnings'])
    
    max_score = 100
    penalty = error_penalty + warning_penalty
    quality_score = max(0, max_score - penalty)
    
    print(f"🏆 품질 점수: {quality_score}/100")
    
    if quality_score >= 90:
        print("  🎉 우수한 템플릿입니다!")
    elif quality_score >= 70:
        print("  👍 양호한 템플릿입니다.")
    elif quality_score >= 50:
        print("  ⚠️  개선이 필요한 템플릿입니다.")
    else:
        print("  🚨 심각한 문제가 있는 템플릿입니다.")

except Exception as e:
    print(f"❌ 최적화된 템플릿 저장 실패: {e}")

EOF
    
    echo ""
    echo "✅ 템플릿 검증 및 최적화 완료"
}

# 사용 예시
echo "🔍 Feature 템플릿 검증 및 최적화 도구"
echo ""
echo "사용법: validate_and_optimize_template <template_file> [optimized_output]"
echo ""
echo "예시:"
echo "  validate_and_optimize_template my_features.json"
echo "  validate_and_optimize_template draft.json final_features.json"

if [ $# -gt 0 ]; then
    validate_and_optimize_template "$@"
fi
```

## 워크플로우 예시

### 일반적인 템플릿 사용 워크플로우

```bash
#!/bin/bash
# complete_template_workflow.sh - 완전한 템플릿 워크플로우

echo "🎯 Feature Definition 완전 워크플로우"
echo ""

# 1. 기본 템플릿 생성
echo "1️⃣ 기본 템플릿 생성"
fs schema-template --output base_template.json
echo ""

# 2. 템플릿 편집
echo "2️⃣ 템플릿 편집 (원하는 features로 수정)"
echo "   편집기가 열립니다..."
${EDITOR:-vim} base_template.json
echo ""

# 3. 템플릿 검증
echo "3️⃣ 템플릿 검증"
./template_validator.sh base_template.json validated_template.json
echo ""

# 4. Feature Group 선택
echo "4️⃣ Feature Group 선택"
echo "사용 가능한 Feature Groups:"
fs list
echo ""
read -p "Feature Group 이름을 입력하세요: " feature_group_name

# 5. 호환성 확인
echo ""
echo "5️⃣ 호환성 확인 (dry-run)"
fs add-features "$feature_group_name" validated_template.json --dry-run
echo ""

# 6. 최종 확인
echo "6️⃣ 최종 확인"
read -p "Feature를 추가하시겠습니까? (y/N): " confirm

if [[ $confirm =~ ^[Yy]$ ]]; then
    echo ""
    echo "7️⃣ Feature 추가 실행"
    fs add-features "$feature_group_name" validated_template.json
    
    echo ""
    echo "8️⃣ 결과 확인"
    fs schema "$feature_group_name"
else
    echo "❌ Feature 추가가 취소되었습니다"
fi

echo ""
echo "✅ 워크플로우 완료!"
```

## 관련 명령어

- [`add-features`](12.add-features.md) - 템플릿으로 새로운 feature 추가
- [`schema`](13.schema.md) - 현재 Feature Group 스키마 조회
- [`create`](02.create.md) - 새 Feature Group 생성 시 스키마 정의

## 참고사항

- **표준 구조**: 모든 SageMaker Feature Store feature definition 요소를 포함합니다
- **예시 중심**: 각 타입과 설정에 대한 실용적인 예시를 제공합니다
- **편집 가능**: 생성된 템플릿은 용도에 맞게 자유롭게 편집할 수 있습니다
- **검증 도구**: 별도 검증 스크립트와 함께 사용하여 품질을 보장할 수 있습니다