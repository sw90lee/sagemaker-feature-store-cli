# 13. schema 명령어

Feature Group의 현재 스키마 정보를 조회하는 명령어입니다.

## 기본 사용법

```bash
# 테이블 형태로 스키마 출력
fs schema my-feature-group

# JSON 형태로 스키마 출력
fs schema my-feature-group --output-format json
```

## 명령어 옵션

| 옵션 | 설명 | 기본값 |
|------|------|--------|
| `FEATURE_GROUP_NAME` | 조회할 Feature Group 이름 (필수) | - |
| `--output-format`, `-o` | 출력 형식 (table, json) | table |

## 출력 정보

### 기본 정보
- **Feature Group 이름**: 조회 대상 Feature Group
- **상태**: Feature Group의 현재 상태 (Created, Creating, UpdateFailed 등)
- **Record Identifier**: 레코드 식별자 feature 이름
- **Event Time Feature**: 이벤트 시간 feature 이름
- **Total Features**: 전체 feature 개수

### Feature 상세 정보
- **Feature Name**: 각 feature의 이름
- **Type**: 데이터 타입 (String, Integral, Fractional)
- **Collection Type**: 컬렉션 타입 (List, Set)
- **Collection Name**: 컬렉션 설정 정보

## 상세 사용 예시

### 기본 스키마 조회 (테이블 형태)

```bash
fs schema customer-profiles

# 출력 예시:
# 📊 Feature Group: customer-profiles
# Status: Created
# Record Identifier: customer_id
# Event Time Feature: event_time
# Total Features: 8
# 
# 📋 Feature Definitions:
# --------------------------------------------------------------------------------
# Feature Name                   Type            Collection Type Collection Name
# --------------------------------------------------------------------------------
# customer_id                    String                          
# customer_name                  String                          
# age                           Integral                         
# income                        Fractional                       
# customer_segment              String                          
# purchase_history              String          List            100
# preferred_categories          String          Set             Set
# event_time                    Fractional                       
```

### JSON 형태로 스키마 조회

```bash
fs schema customer-profiles --format json

# 출력 예시:
# {
#   "FeatureGroupName": "customer-profiles",
#   "FeatureGroupStatus": "Created", 
#   "RecordIdentifierFeatureName": "customer_id",
#   "EventTimeFeatureName": "event_time",
#   "FeatureDefinitions": [
#     {
#       "FeatureName": "customer_id",
#       "FeatureType": "String"
#     },
#     {
#       "FeatureName": "customer_name", 
#       "FeatureType": "String"
#     },
#     {
#       "FeatureName": "age",
#       "FeatureType": "Integral"
#     },
#     {
#       "FeatureName": "purchase_history",
#       "FeatureType": "String",
#       "CollectionType": "List",
#       "CollectionConfig": {
#         "VectorConfig": {
#           "Dimension": 100
#         }
#       }
#     }
#   ],
#   "TotalFeatures": 8
# }
```

## 고급 사용 시나리오

### 1. 스키마 비교 시스템

```bash
#!/bin/bash
# schema_comparison.sh - 여러 Feature Group 스키마 비교

compare_schemas() {
    local feature_groups=("$@")
    
    if [ ${#feature_groups[@]} -lt 2 ]; then
        echo "비교를 위해 최소 2개의 Feature Group이 필요합니다"
        return 1
    fi
    
    echo "📊 Feature Group 스키마 비교"
    echo "비교 대상: ${feature_groups[*]}"
    echo ""
    
    # 임시 파일들
    temp_dir="/tmp/schema_comparison_$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$temp_dir"
    
    # 각 Feature Group의 스키마 수집
    for fg in "${feature_groups[@]}"; do
        echo "📋 $fg 스키마 수집 중..."
        
        schema_file="$temp_dir/${fg}_schema.json"
        
        if fs schema "$fg" --format json > "$schema_file"; then
            echo "  ✅ $fg 스키마 수집 완료"
        else
            echo "  ❌ $fg 스키마 수집 실패"
            rm -rf "$temp_dir"
            return 1
        fi
    done
    
    echo ""
    
    # Python을 사용한 상세 비교
    python3 << EOF
import json
import os
from collections import defaultdict

temp_dir = "$temp_dir"
feature_groups = ["${feature_groups[@]}".split()]

# 스키마 데이터 로드
schemas = {}
for fg in feature_groups:
    schema_file = os.path.join(temp_dir, f"{fg}_schema.json")
    with open(schema_file, 'r') as f:
        schemas[fg] = json.load(f)

print("🔍 스키마 비교 분석")
print("=" * 60)
print("")

# 기본 정보 비교
print("📊 기본 정보 비교")
print("-" * 40)
print(f"{'Feature Group':<25} {'Features':<10} {'Status':<15} {'Record ID':<20}")
print("-" * 70)

for fg in feature_groups:
    schema = schemas[fg]
    feature_count = schema.get('TotalFeatures', 0)
    status = schema.get('FeatureGroupStatus', 'Unknown')
    record_id = schema.get('RecordIdentifierFeatureName', 'N/A')
    
    print(f"{fg:<25} {feature_count:<10} {status:<15} {record_id:<20}")

print("")

# Feature 유형별 분포 비교
print("📈 Feature Type 분포 비교")
print("-" * 40)

type_distributions = {}
for fg in feature_groups:
    type_dist = defaultdict(int)
    features = schemas[fg].get('FeatureDefinitions', [])
    
    for feature in features:
        ftype = feature.get('FeatureType', 'Unknown')
        type_dist[ftype] += 1
    
    type_distributions[fg] = dict(type_dist)

# 모든 타입 수집
all_types = set()
for dist in type_distributions.values():
    all_types.update(dist.keys())

print(f"{'Type':<15} " + " ".join([f"{fg:<12}" for fg in feature_groups]))
print("-" * (15 + 12 * len(feature_groups) + len(feature_groups) - 1))

for ftype in sorted(all_types):
    row = f"{ftype:<15}"
    for fg in feature_groups:
        count = type_distributions[fg].get(ftype, 0)
        row += f" {count:<12}"
    print(row)

print("")

# 공통 Feature 분석
print("🤝 공통 Features 분석")
print("-" * 40)

# 각 Feature Group의 feature 이름 수집
feature_sets = {}
for fg in feature_groups:
    features = schemas[fg].get('FeatureDefinitions', [])
    feature_sets[fg] = {f['FeatureName'] for f in features}

# 교집합 (모든 FG에 공통으로 있는 features)
common_features = set.intersection(*feature_sets.values())
print(f"모든 Feature Group에 공통: {len(common_features)}개")
for feature in sorted(common_features):
    print(f"  ✓ {feature}")

print("")

# 차집합 (각 FG에만 있는 unique features)
print("🎯 고유 Features")
print("-" * 40)

for fg in feature_groups:
    unique_features = feature_sets[fg]
    for other_fg in feature_groups:
        if other_fg != fg:
            unique_features = unique_features - feature_sets[other_fg]
    
    print(f"{fg}에만 있는 features: {len(unique_features)}개")
    for feature in sorted(unique_features):
        print(f"  + {feature}")
    print("")

# Collection Type 분석
print("📦 Collection Type 분석")
print("-" * 40)

collection_analysis = {}
for fg in feature_groups:
    features = schemas[fg].get('FeatureDefinitions', [])
    collection_count = {"List": 0, "Set": 0, "None": 0}
    
    for feature in features:
        collection_type = feature.get('CollectionType')
        if collection_type:
            collection_count[collection_type] += 1
        else:
            collection_count["None"] += 1
    
    collection_analysis[fg] = collection_count

print(f"{'FG / Collection':<25} {'List':<8} {'Set':<8} {'None':<8}")
print("-" * 49)

for fg in feature_groups:
    counts = collection_analysis[fg]
    print(f"{fg:<25} {counts['List']:<8} {counts['Set']:<8} {counts['None']:<8}")

print("")

# 스키마 진화 권장사항
print("💡 스키마 진화 권장사항")
print("-" * 40)

# Feature 수 균형
feature_counts = [schemas[fg]['TotalFeatures'] for fg in feature_groups]
min_features = min(feature_counts)
max_features = max(feature_counts)

if max_features - min_features > 10:
    print("1. Feature 수 불균형 감지:")
    print(f"   최소: {min_features}개, 최대: {max_features}개")
    print("   → Feature Group 역할 재검토 필요")

# 공통 feature 부족
if len(common_features) < 3:
    print("2. 공통 Feature 부족:")
    print(f"   현재 공통 features: {len(common_features)}개")
    print("   → 통합 분석이 어려울 수 있습니다")

# 타입 불일치 확인
type_inconsistencies = []
for feature_name in common_features:
    types = set()
    for fg in feature_groups:
        features = schemas[fg].get('FeatureDefinitions', [])
        for feature in features:
            if feature['FeatureName'] == feature_name:
                types.add(feature['FeatureType'])
    
    if len(types) > 1:
        type_inconsistencies.append((feature_name, types))

if type_inconsistencies:
    print("3. 공통 Feature 타입 불일치:")
    for feature_name, types in type_inconsistencies:
        print(f"   {feature_name}: {types}")
    print("   → 타입 통일을 고려해보세요")

if not any([max_features - min_features > 10, len(common_features) < 3, type_inconsistencies]):
    print("✅ 스키마들이 일관성 있게 구성되어 있습니다!")

EOF
    
    echo ""
    echo "📁 스키마 파일들: $temp_dir"
    echo "🔗 비교 완료"
    
    # 정리 옵션
    echo ""
    echo "임시 파일들을 삭제하시겠습니까? (y/N)"
    read -r cleanup_temp
    
    if [[ $cleanup_temp =~ ^[Yy]$ ]]; then
        rm -rf "$temp_dir"
        echo "✅ 임시 파일 정리 완료"
    else
        echo "📁 임시 파일 보관: $temp_dir"
    fi
}

# 사용 예시
compare_schemas "user-profiles" "customer-data" "analytics-features"
```

### 2. 스키마 진화 추적 시스템

```bash
#!/bin/bash
# schema_evolution_tracker.sh - 스키마 변경 추적 시스템

track_schema_evolution() {
    local feature_group="$1"
    local tracking_dir="schema_tracking/$feature_group"
    
    if [ -z "$feature_group" ]; then
        echo "사용법: track_schema_evolution <feature-group-name>"
        return 1
    fi
    
    echo "📈 스키마 진화 추적: $feature_group"
    
    # 추적 디렉토리 생성
    mkdir -p "$tracking_dir"
    
    # 현재 스키마 저장
    timestamp=$(date +%Y%m%d_%H%M%S)
    current_schema="$tracking_dir/schema_$timestamp.json"
    
    echo "💾 현재 스키마 저장 중..."
    if fs schema "$feature_group" --format json > "$current_schema"; then
        echo "✅ 스키마 저장 완료: $current_schema"
    else
        echo "❌ 스키마 저장 실패"
        return 1
    fi
    
    # 이전 스키마들과 비교
    previous_schemas=($(ls -t "$tracking_dir"/schema_*.json 2>/dev/null | tail -n +2))
    
    if [ ${#previous_schemas[@]} -eq 0 ]; then
        echo "ℹ️  첫 번째 스키마 스냅샷입니다"
        
        # 진화 로그 초기화
        evolution_log="$tracking_dir/evolution.log"
        echo "$(date '+%Y-%m-%d %H:%M:%S') | INIT | First schema snapshot" >> "$evolution_log"
        
        return 0
    fi
    
    # 가장 최근 이전 스키마와 비교
    previous_schema="${previous_schemas[0]}"
    
    echo ""
    echo "🔄 이전 스키마와 비교 중..."
    echo "  현재: $(basename $current_schema)"
    echo "  이전: $(basename $previous_schema)"
    
    # Python을 사용한 상세 비교
    python3 << EOF
import json
from datetime import datetime

# 스키마 로드
with open('$current_schema', 'r') as f:
    current = json.load(f)
with open('$previous_schema', 'r') as f:
    previous = json.load(f)

# Feature 정보 추출
current_features = {f['FeatureName']: f for f in current['FeatureDefinitions']}
previous_features = {f['FeatureName']: f for f in previous['FeatureDefinitions']}

current_names = set(current_features.keys())
previous_names = set(previous_features.keys())

# 변경 사항 분석
added_features = current_names - previous_names
removed_features = previous_names - current_names
common_features = current_names & previous_names

print("")
print("📋 스키마 변경 사항 분석")
print("-" * 40)

# 통계 요약
print(f"이전 features: {len(previous_features)}")
print(f"현재 features: {len(current_features)}")
print(f"변경된 features: {len(added_features) + len(removed_features)}")

evolution_events = []

# 추가된 features
if added_features:
    print(f"\n➕ 추가된 Features ({len(added_features)}개):")
    for feature_name in sorted(added_features):
        feature = current_features[feature_name]
        ftype = feature.get('FeatureType', 'Unknown')
        collection = feature.get('CollectionType', '')
        collection_info = f" [{collection}]" if collection else ""
        
        print(f"  + {feature_name} ({ftype}{collection_info})")
        evolution_events.append(f"ADD|{feature_name}|{ftype}{collection_info}")

# 제거된 features (일반적으로 발생하지 않음)
if removed_features:
    print(f"\n➖ 제거된 Features ({len(removed_features)}개):")
    for feature_name in sorted(removed_features):
        feature = previous_features[feature_name]
        ftype = feature.get('FeatureType', 'Unknown')
        print(f"  - {feature_name} ({ftype})")
        evolution_events.append(f"REMOVE|{feature_name}|{ftype}")

# 타입 변경 확인 (드물지만 가능)
type_changes = []
for feature_name in common_features:
    current_type = current_features[feature_name].get('FeatureType')
    previous_type = previous_features[feature_name].get('FeatureType')
    
    if current_type != previous_type:
        type_changes.append({
            'name': feature_name,
            'from': previous_type,
            'to': current_type
        })

if type_changes:
    print(f"\n🔄 타입 변경된 Features ({len(type_changes)}개):")
    for change in type_changes:
        print(f"  ~ {change['name']}: {change['from']} → {change['to']}")
        evolution_events.append(f"CHANGE|{change['name']}|{change['from']}→{change['to']}")

# 변경사항이 없는 경우
if not added_features and not removed_features and not type_changes:
    print("\n✅ 스키마 변경 없음")
    evolution_events.append("NO_CHANGE")

# 진화 이벤트 로그 저장
if evolution_events:
    log_file = "$tracking_dir/evolution.log"
    timestamp_str = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    for event in evolution_events:
        with open(log_file, 'a') as f:
            f.write(f"{timestamp_str} | {event}\n")

print("")
print("📊 진화 통계:")
print(f"  총 스냅샷: {len([f for f in '$(ls $tracking_dir/schema_*.json 2>/dev/null | wc -l)'.split()]) + 1}")
print(f"  추가 events: {len([e for e in evolution_events if e.startswith('ADD')])}")
print(f"  변경 events: {len([e for e in evolution_events if e.startswith('CHANGE')])}")

EOF
    
    # 진화 히스토리 표시
    echo ""
    echo "📚 최근 진화 히스토리:"
    evolution_log="$tracking_dir/evolution.log"
    if [ -f "$evolution_log" ]; then
        tail -10 "$evolution_log" | while read -r line; do
            echo "  $line"
        done
    fi
    
    # 진화 요약 리포트 생성
    summary_report="$tracking_dir/evolution_summary.txt"
    
    cat > "$summary_report" << EOF
# Schema Evolution Summary: $feature_group

생성일: $(date)
추적 시작: $(head -1 "$evolution_log" 2>/dev/null | cut -d'|' -f1 || echo "Unknown")
마지막 업데이트: $(tail -1 "$evolution_log" 2>/dev/null | cut -d'|' -f1 || echo "Unknown")

## 현재 상태
$(fs schema "$feature_group" 2>/dev/null | head -10)

## 최근 변경 이력
$(tail -10 "$evolution_log" 2>/dev/null || echo "변경 이력 없음")

## 스냅샷 파일들
$(ls -la "$tracking_dir"/schema_*.json 2>/dev/null || echo "스냅샷 없음")
EOF
    
    echo ""
    echo "📄 진화 요약 리포트 업데이트됨: $summary_report"
    
    # 오래된 스냅샷 정리 (30일 이상)
    old_snapshots=$(find "$tracking_dir" -name "schema_*.json" -mtime +30 2>/dev/null)
    if [ -n "$old_snapshots" ]; then
        echo ""
        echo "🗑️  오래된 스냅샷 정리 (30일 이상):"
        echo "$old_snapshots" | while read -r old_file; do
            echo "  삭제: $(basename "$old_file")"
            rm -f "$old_file"
        done
    fi
    
    echo ""
    echo "✅ 스키마 진화 추적 완료"
    echo "📁 추적 디렉토리: $tracking_dir"
}

# 사용 예시
track_schema_evolution "my-feature-group"

# 자동 추적을 위한 cron 설정 예시
# 매일 오전 6시에 스키마 변경 추적
# 0 6 * * * /path/to/schema_evolution_tracker.sh "my-feature-group" >> /var/log/schema_tracking.log 2>&1
```

### 3. 스키마 검증 시스템

```bash
#!/bin/bash
# schema_validator.sh - Feature Group 스키마 검증 시스템

validate_schema() {
    local feature_group="$1"
    local validation_profile="${2:-standard}"  # standard, strict, ml, business
    
    if [ -z "$feature_group" ]; then
        echo "사용법: validate_schema <feature-group-name> [validation-profile]"
        echo "Profiles: standard, strict, ml, business"
        return 1
    fi
    
    echo "🔍 스키마 검증 시스템"
    echo "Feature Group: $feature_group"
    echo "검증 프로필: $validation_profile"
    echo ""
    
    # 스키마 정보 수집
    temp_schema="/tmp/${feature_group}_schema_validation.json"
    
    if ! fs schema "$feature_group" --format json > "$temp_schema"; then
        echo "❌ 스키마 정보를 가져올 수 없습니다"
        return 1
    fi
    
    # Python을 사용한 상세 검증
    python3 << EOF
import json
import re
from collections import Counter, defaultdict

# 검증 프로필 설정
VALIDATION_PROFILES = {
    'standard': {
        'max_features': 100,
        'max_feature_name_length': 64,
        'required_features': ['event_time'],
        'discouraged_types': [],
        'max_vector_dimension': 1000,
        'naming_pattern': r'^[a-zA-Z][a-zA-Z0-9_]*$'
    },
    'strict': {
        'max_features': 50,
        'max_feature_name_length': 32,
        'required_features': ['event_time', 'record_id'],
        'discouraged_types': [],
        'max_vector_dimension': 512,
        'naming_pattern': r'^[a-z][a-z0-9_]*$'  # 소문자만
    },
    'ml': {
        'max_features': 200,
        'max_feature_name_length': 64,
        'required_features': ['event_time'],
        'encouraged_types': ['Fractional'],  # ML에 유리한 타입
        'max_vector_dimension': 2048,
        'min_vector_features': 1,
        'naming_pattern': r'^[a-zA-Z][a-zA-Z0-9_]*$'
    },
    'business': {
        'max_features': 75,
        'max_feature_name_length': 48,
        'required_features': ['event_time', 'customer_id'],
        'encouraged_features': ['created_at', 'updated_at'],
        'discouraged_types': [],
        'naming_pattern': r'^[a-zA-Z][a-zA-Z0-9_]*$'
    }
}

profile_config = VALIDATION_PROFILES.get('$validation_profile', VALIDATION_PROFILES['standard'])

# 스키마 로드
with open('$temp_schema', 'r') as f:
    schema = json.load(f)

features = schema.get('FeatureDefinitions', [])
feature_count = len(features)

print(f"🔍 스키마 검증 리포트 ($validation_profile 프로필)")
print("=" * 60)
print(f"Feature Group: $feature_group")
print(f"총 Features: {feature_count}")
print(f"상태: {schema.get('FeatureGroupStatus', 'Unknown')}")
print("")

# 검증 결과 저장
validation_results = {
    'passed': [],
    'warnings': [],
    'errors': [],
    'recommendations': []
}

# 1. Feature 개수 검증
max_features = profile_config.get('max_features', 100)
if feature_count > max_features:
    validation_results['warnings'].append(
        f"Feature 수가 많습니다 ({feature_count}개 > {max_features}개 권장)"
    )
else:
    validation_results['passed'].append(f"Feature 수 적절함 ({feature_count}개)")

# 2. 필수 Feature 검증
required_features = profile_config.get('required_features', [])
feature_names = {f['FeatureName'].lower() for f in features}

for req_feature in required_features:
    if req_feature.lower() not in feature_names:
        validation_results['errors'].append(f"필수 Feature 누락: {req_feature}")
    else:
        validation_results['passed'].append(f"필수 Feature 존재: {req_feature}")

# 3. Feature 이름 규칙 검증
naming_pattern = profile_config.get('naming_pattern', r'^[a-zA-Z][a-zA-Z0-9_]*$')
max_name_length = profile_config.get('max_feature_name_length', 64)

for feature in features:
    name = feature['FeatureName']
    
    # 길이 검증
    if len(name) > max_name_length:
        validation_results['warnings'].append(f"Feature 이름이 깁니다: {name} ({len(name)}자)")
    
    # 패턴 검증
    if not re.match(naming_pattern, name):
        validation_results['warnings'].append(f"이름 규칙 위반: {name}")
    
    # 예약어 검증
    reserved_words = ['time', 'date', 'timestamp', 'id', 'key']
    if name.lower() in reserved_words:
        validation_results['warnings'].append(f"예약어 사용: {name}")

# 4. Feature 타입 분포 검증
type_counter = Counter(f['FeatureType'] for f in features)

print("📊 Feature Type 분포:")
for ftype, count in type_counter.most_common():
    percentage = (count / feature_count) * 100
    print(f"  {ftype}: {count}개 ({percentage:.1f}%)")

# 타입별 권장사항
if '$validation_profile' == 'ml':
    fractional_ratio = type_counter.get('Fractional', 0) / feature_count
    if fractional_ratio < 0.3:
        validation_results['recommendations'].append(
            f"ML용도로 Fractional 타입이 부족할 수 있습니다 ({fractional_ratio:.1%})"
        )

string_ratio = type_counter.get('String', 0) / feature_count  
if string_ratio > 0.7:
    validation_results['warnings'].append(
        f"String 타입이 많습니다 ({string_ratio:.1%}). 카테고리 인코딩을 고려해보세요"
    )

# 5. Collection 타입 검증
collection_features = [f for f in features if f.get('CollectionType')]
vector_features = [f for f in collection_features if f.get('CollectionType') == 'List']

if vector_features:
    print(f"\n📦 Vector Features: {len(vector_features)}개")
    
    max_vector_dim = profile_config.get('max_vector_dimension', 1000)
    
    for vf in vector_features:
        name = vf['FeatureName']
        config = vf.get('CollectionConfig', {})
        vector_config = config.get('VectorConfig', {})
        dimension = vector_config.get('Dimension', 0)
        
        print(f"  {name}: {dimension}차원")
        
        if dimension > max_vector_dim:
            validation_results['warnings'].append(
                f"벡터 차원이 큽니다: {name} ({dimension}차원)"
            )
        elif dimension == 0:
            validation_results['errors'].append(f"벡터 차원 미설정: {name}")

# ML 프로필 특별 검증
if '$validation_profile' == 'ml':
    min_vector_features = profile_config.get('min_vector_features', 0)
    if len(vector_features) < min_vector_features:
        validation_results['recommendations'].append(
            f"ML용도로 벡터 Feature가 부족할 수 있습니다 ({len(vector_features)}개)"
        )

# 6. 비즈니스 로직 검증
business_patterns = {
    'timestamp_features': [f for f in features if any(keyword in f['FeatureName'].lower() 
                          for keyword in ['time', 'date', 'timestamp', 'created', 'updated'])],
    'id_features': [f for f in features if any(keyword in f['FeatureName'].lower() 
                   for keyword in ['id', 'identifier', 'key'])],
    'metric_features': [f for f in features if f['FeatureType'] in ['Fractional', 'Integral'] 
                       and any(keyword in f['FeatureName'].lower() 
                       for keyword in ['count', 'amount', 'value', 'score', 'rate'])]
}

print(f"\n🏢 비즈니스 패턴 분석:")
for pattern_name, pattern_features in business_patterns.items():
    print(f"  {pattern_name.replace('_', ' ').title()}: {len(pattern_features)}개")

# 7. 데이터 품질 지표 검증
quality_indicators = []

# Event Time Feature 확인
event_time_feature = schema.get('EventTimeFeatureName')
if event_time_feature:
    event_time_type = next((f['FeatureType'] for f in features 
                          if f['FeatureName'] == event_time_feature), None)
    if event_time_type != 'Fractional':
        validation_results['warnings'].append(
            f"Event Time Feature가 Fractional 타입이 아닙니다: {event_time_type}"
        )
    else:
        validation_results['passed'].append("Event Time Feature 타입 적절함")

# Record Identifier 확인
record_id_feature = schema.get('RecordIdentifierFeatureName')
if record_id_feature:
    record_id_type = next((f['FeatureType'] for f in features 
                         if f['FeatureName'] == record_id_feature), None)
    if record_id_type != 'String':
        validation_results['warnings'].append(
            f"Record Identifier가 String 타입이 아닙니다: {record_id_type}"
        )

# 검증 결과 출력
print(f"\n📋 검증 결과")
print("-" * 40)

if validation_results['passed']:
    print(f"✅ 통과 ({len(validation_results['passed'])}개):")
    for result in validation_results['passed']:
        print(f"  ✓ {result}")

if validation_results['warnings']:
    print(f"\n⚠️  경고 ({len(validation_results['warnings'])}개):")
    for result in validation_results['warnings']:
        print(f"  ⚠ {result}")

if validation_results['errors']:
    print(f"\n❌ 오류 ({len(validation_results['errors'])}개):")
    for result in validation_results['errors']:
        print(f"  ✗ {result}")

if validation_results['recommendations']:
    print(f"\n💡 권장사항 ({len(validation_results['recommendations'])}개):")
    for result in validation_results['recommendations']:
        print(f"  💡 {result}")

# 전체 점수 계산
total_checks = (len(validation_results['passed']) + 
               len(validation_results['warnings']) + 
               len(validation_results['errors']))
passed_checks = len(validation_results['passed'])
score = (passed_checks / total_checks * 100) if total_checks > 0 else 0

print(f"\n📊 검증 점수: {score:.1f}% ({passed_checks}/{total_checks})")

if score >= 90:
    print("🏆 우수한 스키마 설계입니다!")
elif score >= 70:
    print("👍 양호한 스키마입니다. 몇 가지 개선점이 있습니다.")
elif score >= 50:
    print("⚠️ 스키마 개선이 필요합니다.")
else:
    print("🚨 스키마에 심각한 문제가 있습니다.")

# 검증 리포트 파일 생성
import os
os.system('mkdir -p schema_validations')

report_file = f"schema_validations/{schema['FeatureGroupName']}_validation_{profile_config}.txt"
with open(report_file.replace('$validation_profile', '$validation_profile'), 'w') as f:
    f.write(f"Schema Validation Report\\n")
    f.write(f"Feature Group: {schema['FeatureGroupName']}\\n")
    f.write(f"Profile: $validation_profile\\n")
    f.write(f"Date: $(date)\\n")
    f.write(f"Score: {score:.1f}%\\n\\n")
    
    for category, results in validation_results.items():
        if results:
            f.write(f"{category.upper()}:\\n")
            for result in results:
                f.write(f"  - {result}\\n")
            f.write("\\n")

print(f"\\n📄 검증 리포트 저장됨: schema_validations/{schema['FeatureGroupName']}_validation_$validation_profile.txt")

EOF
    
    # 정리
    rm -f "$temp_schema"
    
    echo ""
    echo "✅ 스키마 검증 완료"
}

# 사용 예시들
echo "스키마 검증 예시:"
echo ""
echo "# 표준 검증"
echo "validate_schema \"my-feature-group\" \"standard\""
echo ""
echo "# ML 프로젝트용 엄격한 검증"  
echo "validate_schema \"ml-features\" \"ml\""
echo ""
echo "# 비즈니스 데이터용 검증"
echo "validate_schema \"customer-data\" \"business\""
echo ""
echo "# 매우 엄격한 검증"
echo "validate_schema \"critical-features\" \"strict\""
```

### 4. 스키마 문서화 생성기

```bash
#!/bin/bash
# schema_documentation_generator.sh - 스키마 자동 문서화

generate_schema_docs() {
    local feature_groups=("$@")
    local output_dir="schema_docs"
    local timestamp=$(date +%Y%m%d_%H%M%S)
    
    if [ ${#feature_groups[@]} -eq 0 ]; then
        echo "사용법: generate_schema_docs <feature-group-1> [feature-group-2] ..."
        return 1
    fi
    
    echo "📚 스키마 문서화 생성기"
    echo "대상 Feature Groups: ${feature_groups[*]}"
    echo ""
    
    # 출력 디렉토리 생성
    mkdir -p "$output_dir"
    
    # 마스터 인덱스 HTML 생성
    index_file="$output_dir/index.html"
    
    cat > "$index_file" << 'HTML_HEADER'
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Feature Store 스키마 문서</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            margin: 0; 
            padding: 20px; 
            background-color: #f5f5f5; 
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background: white; 
            border-radius: 8px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.1); 
            padding: 30px; 
        }
        .header { 
            border-bottom: 3px solid #007acc; 
            padding-bottom: 20px; 
            margin-bottom: 30px; 
        }
        .feature-group { 
            margin: 20px 0; 
            padding: 20px; 
            border: 1px solid #ddd; 
            border-radius: 6px; 
            background-color: #fafafa; 
        }
        .feature-table { 
            width: 100%; 
            border-collapse: collapse; 
            margin: 15px 0; 
        }
        .feature-table th, .feature-table td { 
            border: 1px solid #ddd; 
            padding: 12px; 
            text-align: left; 
        }
        .feature-table th { 
            background-color: #007acc; 
            color: white; 
        }
        .feature-table tbody tr:nth-child(even) { 
            background-color: #f9f9f9; 
        }
        .type-string { color: #28a745; font-weight: bold; }
        .type-integral { color: #007acc; font-weight: bold; }
        .type-fractional { color: #dc3545; font-weight: bold; }
        .collection-list { background-color: #fff3cd; padding: 2px 6px; border-radius: 3px; }
        .collection-set { background-color: #d4edda; padding: 2px 6px; border-radius: 3px; }
        .stats { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
            gap: 15px; 
            margin: 20px 0; 
        }
        .stat-card { 
            background: white; 
            padding: 15px; 
            border-radius: 6px; 
            border-left: 4px solid #007acc; 
            text-align: center; 
        }
        .stat-number { 
            font-size: 2em; 
            font-weight: bold; 
            color: #007acc; 
        }
        .nav-links { 
            margin: 20px 0; 
        }
        .nav-links a { 
            display: inline-block; 
            margin-right: 15px; 
            padding: 8px 15px; 
            background-color: #007acc; 
            color: white; 
            text-decoration: none; 
            border-radius: 4px; 
        }
        .nav-links a:hover { 
            background-color: #0056b3; 
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🗃️ Feature Store 스키마 문서</h1>
            <p>생성일: <strong>TIMESTAMP_PLACEHOLDER</strong></p>
            <p>Feature Groups: <strong>COUNT_PLACEHOLDER</strong>개</p>
        </div>
HTML_HEADER
    
    # 각 Feature Group 문서화
    total_features=0
    
    for fg in "${feature_groups[@]}"; do
        echo "📊 $fg 문서화 중..."
        
        # 스키마 정보 수집
        schema_file="/tmp/${fg}_schema_doc.json"
        
        if ! fs schema "$fg" --format json > "$schema_file"; then
            echo "  ❌ $fg 스키마 수집 실패"
            continue
        fi
        
        # Python을 사용한 HTML 생성
        python3 << EOF
import json
from collections import Counter

with open('$schema_file', 'r') as f:
    schema = json.load(f)

fg_name = schema['FeatureGroupName']
features = schema.get('FeatureDefinitions', [])
feature_count = len(features)
status = schema.get('FeatureGroupStatus', 'Unknown')
record_id = schema.get('RecordIdentifierFeatureName', 'N/A')
event_time = schema.get('EventTimeFeatureName', 'N/A')

# Feature type 통계
type_counter = Counter(f['FeatureType'] for f in features)
collection_counter = Counter(f.get('CollectionType', 'None') for f in features)

# HTML 섹션 생성
html_content = f'''
        <div class="feature-group" id="{fg_name}">
            <h2>📊 {fg_name}</h2>
            
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-number">{feature_count}</div>
                    <div>Total Features</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">{type_counter.get('String', 0)}</div>
                    <div>String Features</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">{type_counter.get('Integral', 0)}</div>
                    <div>Integral Features</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">{type_counter.get('Fractional', 0)}</div>
                    <div>Fractional Features</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">{collection_counter.get('List', 0)}</div>
                    <div>Vector Features</div>
                </div>
            </div>
            
            <h3>📋 기본 정보</h3>
            <ul>
                <li><strong>상태:</strong> {status}</li>
                <li><strong>Record Identifier:</strong> {record_id}</li>
                <li><strong>Event Time Feature:</strong> {event_time}</li>
                <li><strong>총 Features:</strong> {feature_count}개</li>
            </ul>
            
            <h3>🔍 Feature 정의</h3>
            <table class="feature-table">
                <thead>
                    <tr>
                        <th>Feature Name</th>
                        <th>Type</th>
                        <th>Collection</th>
                        <th>Dimension</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
'''

for feature in sorted(features, key=lambda x: x['FeatureName']):
    name = feature['FeatureName']
    ftype = feature['FeatureType']
    collection_type = feature.get('CollectionType', '')
    description = feature.get('Description', '-')
    
    # Type 클래스 설정
    type_class = f"type-{ftype.lower()}"
    
    # Collection 정보
    collection_display = ''
    dimension = ''
    
    if collection_type == 'List':
        collection_display = '<span class="collection-list">List</span>'
        config = feature.get('CollectionConfig', {})
        vector_config = config.get('VectorConfig', {})
        dimension = str(vector_config.get('Dimension', '-'))
    elif collection_type == 'Set':
        collection_display = '<span class="collection-set">Set</span>'
    
    html_content += f'''
                    <tr>
                        <td><strong>{name}</strong></td>
                        <td><span class="{type_class}">{ftype}</span></td>
                        <td>{collection_display}</td>
                        <td>{dimension}</td>
                        <td>{description}</td>
                    </tr>'''

html_content += '''
                </tbody>
            </table>
        </div>
'''

# 파일에 추가
with open('$index_file', 'a') as f:
    f.write(html_content)

print(f"  ✅ {fg_name}: {feature_count}개 features")

EOF
        
        total_features=$((total_features + $(jq '.TotalFeatures' "$schema_file")))
        rm -f "$schema_file"
    done
    
    # HTML 마무리
    cat >> "$index_file" << 'HTML_FOOTER'
        
        <div class="footer" style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #ddd; text-align: center; color: #666;">
            <p>📄 이 문서는 SageMaker Feature Store CLI를 사용하여 자동 생성되었습니다.</p>
        </div>
    </div>
    
    <script>
        // 간단한 검색 기능
        document.addEventListener('DOMContentLoaded', function() {
            // 네비게이션 링크 추가
            const navLinks = document.createElement('div');
            navLinks.className = 'nav-links';
            navLinks.innerHTML = '<h3>📌 Quick Navigation</h3>';
            
            document.querySelectorAll('.feature-group').forEach(fg => {
                const id = fg.id;
                const name = fg.querySelector('h2').textContent;
                navLinks.innerHTML += `<a href="#${id}">${name}</a>`;
            });
            
            document.querySelector('.header').appendChild(navLinks);
        });
    </script>
</body>
</html>
HTML_FOOTER
    
    # 플레이스홀더 교체
    sed -i "s/TIMESTAMP_PLACEHOLDER/$(date)/" "$index_file"
    sed -i "s/COUNT_PLACEHOLDER/${#feature_groups[@]}/" "$index_file"
    
    # 추가 리포트 생성
    summary_file="$output_dir/summary.txt"
    
    cat > "$summary_file" << EOF
Feature Store Schema Documentation Summary
=========================================

Generated: $(date)
Feature Groups: ${#feature_groups[@]}
Total Features: $total_features

Feature Groups:
$(printf "  - %s\n" "${feature_groups[@]}")

Files Generated:
  - index.html       : Main documentation
  - summary.txt      : This summary

To view the documentation, open:
  file://$(pwd)/$index_file
EOF
    
    echo ""
    echo "📚 스키마 문서화 완료!"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "Feature Groups: ${#feature_groups[@]}개"
    echo "총 Features: $total_features개"
    echo ""
    echo "📄 생성된 파일들:"
    echo "  - HTML 문서: $index_file"
    echo "  - 요약 파일: $summary_file"
    echo ""
    echo "🌐 브라우저에서 보기:"
    echo "  file://$(pwd)/$index_file"
    
    # 브라우저로 자동 열기 (선택사항)
    if command -v xdg-open >/dev/null; then
        echo ""
        echo "브라우저에서 자동으로 열까요? (y/N)"
        read -r open_browser
        if [[ $open_browser =~ ^[Yy]$ ]]; then
            xdg-open "$index_file"
        fi
    fi
}

# 사용 예시
generate_schema_docs "customer-profiles" "product-catalog" "user-interactions"
```

### 5. 스키마 기반 코드 생성기

```bash
#!/bin/bash
# schema_code_generator.sh - 스키마 기반 코드 자동 생성

generate_code_from_schema() {
    local feature_group="$1"
    local language="${2:-python}"  # python, java, typescript
    local output_dir="generated_code"
    
    if [ -z "$feature_group" ]; then
        echo "사용법: generate_code_from_schema <feature-group-name> [language]"
        echo "Languages: python, java, typescript"
        return 1
    fi
    
    echo "🔧 스키마 기반 코드 생성기"
    echo "Feature Group: $feature_group"
    echo "언어: $language"
    echo ""
    
    # 스키마 정보 수집
    schema_file="/tmp/${feature_group}_codegen.json"
    
    if ! fs schema "$feature_group" --format json > "$schema_file"; then
        echo "❌ 스키마 정보를 가져올 수 없습니다"
        return 1
    fi
    
    # 출력 디렉토리 생성
    mkdir -p "$output_dir/$language"
    
    # 언어별 코드 생성
    case "$language" in
        "python")
            generate_python_code "$feature_group" "$schema_file" "$output_dir/python"
            ;;
        "java")
            generate_java_code "$feature_group" "$schema_file" "$output_dir/java"
            ;;
        "typescript")
            generate_typescript_code "$feature_group" "$schema_file" "$output_dir/typescript"
            ;;
        *)
            echo "❌ 지원하지 않는 언어: $language"
            return 1
            ;;
    esac
    
    rm -f "$schema_file"
}

generate_python_code() {
    local feature_group="$1"
    local schema_file="$2"
    local output_dir="$3"
    
    echo "🐍 Python 코드 생성 중..."
    
    python3 << EOF
import json
from datetime import datetime

with open('$schema_file', 'r') as f:
    schema = json.load(f)

fg_name = schema['FeatureGroupName']
features = schema.get('FeatureDefinitions', [])
record_id_feature = schema.get('RecordIdentifierFeatureName', 'record_id')
event_time_feature = schema.get('EventTimeFeatureName', 'event_time')

# 클래스명 생성 (PascalCase)
class_name = ''.join(word.capitalize() for word in fg_name.replace('-', '_').split('_'))

# Python 데이터 클래스 생성
python_code = f'''"""
Auto-generated Feature Store model for {fg_name}
Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""

from typing import Optional, List, Dict, Any, Union
from dataclasses import dataclass
from datetime import datetime
import boto3
import json


@dataclass
class {class_name}Feature:
    """Feature data class for {fg_name}"""
'''

# 각 feature를 클래스 필드로 추가
for feature in features:
    name = feature['FeatureName']
    ftype = feature['FeatureType']
    collection_type = feature.get('CollectionType')
    
    # Python 타입 매핑
    python_type = 'str'  # 기본값
    if ftype == 'Integral':
        python_type = 'int'
    elif ftype == 'Fractional':
        python_type = 'float'
    
    if collection_type == 'List':
        python_type = f'List[{python_type}]'
    elif collection_type == 'Set':
        python_type = f'List[{python_type}]'  # Feature Store는 내부적으로 리스트 사용
    
    # Optional 처리 (record_id와 event_time 제외)
    if name not in [record_id_feature, event_time_feature]:
        python_type = f'Optional[{python_type}]'
        default_value = ' = None'
    else:
        default_value = ''
    
    python_code += f'    {name}: {python_type}{default_value}\n'

# Helper 메소드들 추가
python_code += f'''

    def to_feature_record(self) -> Dict[str, Any]:
        """Convert to Feature Store record format"""
        record = {{}}
        
        for field_name, field_value in self.__dict__.items():
            if field_value is not None:
                if isinstance(field_value, (list, tuple)):
                    record[field_name] = [str(item) for item in field_value]
                elif isinstance(field_value, (int, float)):
                    record[field_name] = str(field_value)
                else:
                    record[field_name] = str(field_value)
        
        return record
    
    @classmethod
    def from_feature_record(cls, record: Dict[str, str]) -> '{class_name}Feature':
        """Create instance from Feature Store record"""
        kwargs = {{}}
        
'''

# from_feature_record 메소드의 필드별 파싱 로직
for feature in features:
    name = feature['FeatureName']
    ftype = feature['FeatureType']
    collection_type = feature.get('CollectionType')
    
    python_code += f'''        if '{name}' in record:
            value = record['{name}']
            if value:  # 빈 문자열이 아닌 경우
'''
    
    if collection_type:
        python_code += f'''                # Collection type parsing
                if isinstance(value, str):
                    value = json.loads(value) if value.startswith('[') else [value]
'''
        if ftype == 'Integral':
            python_code += f'                kwargs["{name}"] = [int(x) for x in value]\n'
        elif ftype == 'Fractional':
            python_code += f'                kwargs["{name}"] = [float(x) for x in value]\n'
        else:
            python_code += f'                kwargs["{name}"] = value\n'
    else:
        if ftype == 'Integral':
            python_code += f'                kwargs["{name}"] = int(value)\n'
        elif ftype == 'Fractional':
            python_code += f'                kwargs["{name}"] = float(value)\n'
        else:
            python_code += f'                kwargs["{name}"] = value\n'

python_code += f'''        
        return cls(**kwargs)


class {class_name}Client:
    """Feature Store client for {fg_name}"""
    
    def __init__(self, region_name: str = None):
        self.feature_group_name = '{fg_name}'
        self.sagemaker_client = boto3.client('sagemaker-featurestore-runtime', 
                                           region_name=region_name)
    
    def get_record(self, {record_id_feature}: str, 
                   feature_names: Optional[List[str]] = None) -> Optional[{class_name}Feature]:
        """Get a single record from the feature store"""
        try:
            kwargs = {{
                'FeatureGroupName': self.feature_group_name,
                'RecordIdentifierValueAsString': {record_id_feature}
            }}
            
            if feature_names:
                kwargs['FeatureNames'] = feature_names
            
            response = self.sagemaker_client.get_record(**kwargs)
            
            if 'Record' in response:
                record_dict = {{item['FeatureName']: item['ValueAsString'] 
                              for item in response['Record']}}
                return {class_name}Feature.from_feature_record(record_dict)
            
            return None
            
        except Exception as e:
            print(f"Error getting record: {{e}}")
            return None
    
    def put_record(self, feature_data: {class_name}Feature) -> bool:
        """Put a record into the feature store"""
        try:
            record_dict = feature_data.to_feature_record()
            
            # Feature Store 형식으로 변환
            record_list = [
                {{'FeatureName': name, 'ValueAsString': str(value)}}
                for name, value in record_dict.items()
            ]
            
            self.sagemaker_client.put_record(
                FeatureGroupName=self.feature_group_name,
                Record=record_list
            )
            
            return True
            
        except Exception as e:
            print(f"Error putting record: {{e}}")
            return False
    
    def batch_get_records(self, record_ids: List[str], 
                         feature_names: Optional[List[str]] = None) -> List[{class_name}Feature]:
        """Get multiple records from the feature store"""
        results = []
        
        for record_id in record_ids:
            record = self.get_record(record_id, feature_names)
            if record:
                results.append(record)
        
        return results


# Example usage
if __name__ == "__main__":
    # Create client
    client = {class_name}Client()
    
    # Example feature data
    feature_data = {class_name}Feature(
'''

# 예제 데이터 생성
example_values = []
for feature in features:
    name = feature['FeatureName']
    ftype = feature['FeatureType']
    collection_type = feature.get('CollectionType')
    
    if name == record_id_feature:
        example_values.append(f'        {name}="example-123"')
    elif name == event_time_feature:
        example_values.append(f'        {name}=int(datetime.now().timestamp())')
    else:
        if collection_type:
            if ftype == 'Integral':
                example_values.append(f'        {name}=[1, 2, 3]')
            elif ftype == 'Fractional':
                example_values.append(f'        {name}=[1.0, 2.0, 3.0]')
            else:
                example_values.append(f'        {name}=["value1", "value2"]')
        else:
            if ftype == 'Integral':
                example_values.append(f'        {name}=42')
            elif ftype == 'Fractional':
                example_values.append(f'        {name}=3.14')
            else:
                example_values.append(f'        {name}="example_value"')

python_code += ',\n'.join(example_values)

python_code += f'''
    )
    
    # Put record
    print("Putting record...")
    success = client.put_record(feature_data)
    print(f"Put record success: {{success}}")
    
    # Get record
    print("Getting record...")
    retrieved = client.get_record("example-123")
    print(f"Retrieved record: {{retrieved}}")
'''

# 파일 저장
output_file = f'$output_dir/{fg_name.replace("-", "_")}_model.py'
with open(output_file, 'w') as f:
    f.write(python_code)

print(f"  ✅ Python 모델 클래스: {output_file}")

# 추가로 유틸리티 함수 생성
util_code = f'''"""
Utility functions for {fg_name} Feature Store operations
"""

import pandas as pd
from typing import List, Dict, Any
from .{fg_name.replace("-", "_")}_model import {class_name}Feature, {class_name}Client


def dataframe_to_features(df: pd.DataFrame) -> List[{class_name}Feature]:
    """Convert pandas DataFrame to list of Feature objects"""
    features = []
    
    for _, row in df.iterrows():
        kwargs = {{}}
        for column in df.columns:
            if pd.notna(row[column]):
                kwargs[column] = row[column]
        
        features.append({class_name}Feature(**kwargs))
    
    return features


def features_to_dataframe(features: List[{class_name}Feature]) -> pd.DataFrame:
    """Convert list of Feature objects to pandas DataFrame"""
    data = []
    
    for feature in features:
        data.append(feature.__dict__)
    
    return pd.DataFrame(data)


def validate_feature_data(feature: {class_name}Feature) -> List[str]:
    """Validate feature data and return list of errors"""
    errors = []
    
    # Required field validation
    if not getattr(feature, '{record_id_feature}', None):
        errors.append(f"Missing required field: {record_id_feature}")
    
    if not getattr(feature, '{event_time_feature}', None):
        errors.append(f"Missing required field: {event_time_feature}")
    
'''

# 타입별 검증 로직 추가
for feature in features:
    name = feature['FeatureName']
    ftype = feature['FeatureType']
    
    if name not in [record_id_feature, event_time_feature]:
        continue
    
    util_code += f'''    # Validate {name}
    {name}_value = getattr(feature, '{name}', None)
    if {name}_value is not None:
'''
    
    if ftype == 'Integral':
        util_code += f'        if not isinstance({name}_value, int):\n'
        util_code += f'            errors.append(f"{name} must be an integer")\n'
    elif ftype == 'Fractional':
        util_code += f'        if not isinstance({name}_value, (int, float)):\n'
        util_code += f'            errors.append(f"{name} must be a number")\n'

util_code += '''
    return errors


def batch_put_features(client: {class_name}Client, features: List[{class_name}Feature], 
                      batch_size: int = 100) -> Dict[str, int]:
    """Batch put multiple features with error handling"""
    results = {"success": 0, "failed": 0, "errors": []}
    
    for i in range(0, len(features), batch_size):
        batch = features[i:i + batch_size]
        
        for feature in batch:
            # Validate before putting
            validation_errors = validate_feature_data(feature)
            if validation_errors:
                results["failed"] += 1
                results["errors"].extend(validation_errors)
                continue
            
            # Put record
            if client.put_record(feature):
                results["success"] += 1
            else:
                results["failed"] += 1
    
    return results
'''

util_output_file = f'$output_dir/{fg_name.replace("-", "_")}_utils.py'
with open(util_output_file, 'w') as f:
    f.write(util_code)

print(f"  ✅ Python 유틸리티: {util_output_file}")

EOF
}

# 사용 예시
echo "Python 코드 생성 예시:"
echo "generate_python_code \"customer-profiles\" \"schema.json\" \"output/python\""
```

## 트러블슈팅

### 일반적인 오류들

```bash
# Feature Group을 찾을 수 없음
❌ 오류: 피처 그룹 'non-existent'을 찾을 수 없습니다.
# 해결: Feature Group 이름 확인

# 권한 부족
❌ AWS 오류: AccessDeniedException
# 해결: SageMaker DescribeFeatureGroup 권한 필요

# 잘못된 출력 형식
❌ Invalid value for "--output-format"
# 해결: table 또는 json 사용
```

### 스키마 정보가 표시되지 않는 경우

```bash
#!/bin/bash
# schema_troubleshoot.sh

diagnose_schema_issues() {
    local feature_group="$1"
    
    echo "🔧 스키마 조회 문제 진단"
    echo "Feature Group: $feature_group"
    echo ""
    
    # 1. Feature Group 존재 확인
    echo "1. Feature Group 존재 확인..."
    if aws sagemaker describe-feature-group \
       --feature-group-name "$feature_group" >/dev/null 2>&1; then
        echo "  ✅ Feature Group 존재함"
    else
        echo "  ❌ Feature Group이 존재하지 않습니다"
        echo "  💡 사용 가능한 Feature Groups:"
        fs list | head -10
        return 1
    fi
    
    # 2. Feature Group 상태 확인
    echo ""
    echo "2. Feature Group 상태 확인..."
    status=$(aws sagemaker describe-feature-group \
            --feature-group-name "$feature_group" \
            --query 'FeatureGroupStatus' --output text)
    
    case "$status" in
        "Created")
            echo "  ✅ 상태 정상: $status"
            ;;
        "Creating")
            echo "  ⏳ 생성 중: $status"
            echo "  💡 생성 완료까지 기다려주세요"
            ;;
        "CreateFailed")
            echo "  ❌ 생성 실패: $status"
            echo "  💡 Feature Group 재생성이 필요할 수 있습니다"
            ;;
        *)
            echo "  ⚠️  알 수 없는 상태: $status"
            ;;
    esac
    
    # 3. 권한 확인
    echo ""
    echo "3. 권한 확인..."
    if aws sts get-caller-identity >/dev/null 2>&1; then
        echo "  ✅ AWS 인증 성공"
        
        identity=$(aws sts get-caller-identity --query 'Arn' --output text)
        echo "  현재 사용자: $identity"
    else
        echo "  ❌ AWS 인증 실패"
        echo "  💡 AWS 자격증명을 확인해주세요"
        return 1
    fi
    
    # 4. 실제 스키마 조회 테스트
    echo ""
    echo "4. 스키마 조회 테스트..."
    
    if fs schema "$feature_group" --format json >/dev/null 2>&1; then
        echo "  ✅ 스키마 조회 성공"
        
        feature_count=$(fs schema "$feature_group" --format json | jq '.TotalFeatures')
        echo "  Feature 수: $feature_count"
    else
        echo "  ❌ 스키마 조회 실패"
        echo "  💡 상세 오류 확인:"
        fs schema "$feature_group" --format json 2>&1 | head -5
    fi
    
    echo ""
    echo "🔍 진단 완료"
}

# 사용 예시
diagnose_schema_issues "problematic-feature-group"
```

## 관련 명령어

- [`add-features`](12.add-features.md) - 새로운 feature 추가
- [`schema-template`](14.schema-template.md) - Feature definition 템플릿 생성
- [`list`](01.list.md) - Feature Group 목록 확인
- [`create`](02.create.md) - 새 Feature Group 생성

## 참고사항

- **실시간 정보**: 현재 Feature Group의 최신 스키마 정보를 제공합니다
- **JSON 출력**: API 통합이나 자동화에 적합한 구조화된 데이터를 제공합니다
- **테이블 출력**: 사람이 읽기 쉬운 형태로 정보를 표시합니다
- **메타데이터 포함**: Feature 정의뿐만 아니라 Feature Group의 전체 메타데이터를 제공합니다